# Copyright (C) 2016 Intel Corporation.   All Rights Reserved.
#
# Permission is hereby granted, free of charge, to any person obtaining a
# copy of this software and associated documentation files (the "Software"),
# to deal in the Software without restriction, including without limitation
# the rights to use, copy, modify, merge, publish, distribute, sublicense,
# and/or sell copies of the Software, and to permit persons to whom the
# Software is furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice (including the next
# paragraph) shall be included in all copies or substantial portions of the
# Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
# IN THE SOFTWARE.
#
# Provides definitions for events.

enum GroupType
{
    APIClearRenderTarget,
    APIDraw,
    APIDrawWakeAllThreads,
    APIDrawIndexed,
    APIDispatch,
    APIStoreTiles,
    APIGetDrawContext,
    APISync,
    APIWaitForIdle,
    FEProcessDraw,
    FEProcessDrawIndexed,
    FEFetchShader,
    FEVertexShader,
    FEHullShader,
    FETessellation,
    FEDomainShader,
    FEGeometryShader,
    FEStreamout,
    FEPAAssemble,
    FEBinPoints,
    FEBinLines,
    FEBinTriangles,
    FETriangleSetup,
    FEViewportCull,
    FEGuardbandClip,
    FEClipPoints,
    FEClipLines,
    FEClipTriangles,
    FECullZeroAreaAndBackface,
    FECullBetweenCenters,
    FEProcessStoreTiles,
    FEProcessInvalidateTiles,
    WorkerWorkOnFifoBE,
    WorkerFoundWork,
    BELoadTiles,
    BEDispatch,
    BEClear,
    BERasterizeLine,
    BERasterizeTriangle,
    BETriangleSetup,
    BEStepSetup,
    BECullZeroArea,
    BEEmptyTriangle,
    BETrivialAccept,
    BETrivialReject,
    BERasterizePartial,
    BEPixelBackend,
    BESetup,
    BEBarycentric,
    BEEarlyDepthTest,
    BEPixelShader,
    BESingleSampleBackend,
    BEPixelRateBackend,
    BESampleRateBackend,
    BENullBackend,
    BELateDepthTest,
    BEOutputMerger,
    BEStoreTiles,
    BEEndTile,
    WorkerWaitForThreadEvent,
};

event Start
{
    GroupType type;
    uint32_t id;
};

event End
{
    GroupType type;
    uint32_t count;
};

event ThreadStartApiEvent
{
};

event ThreadStartWorkerEvent
{
};

event DrawInstancedEvent
{
    uint32_t drawId;
    uint32_t topology;
    uint32_t numVertices;
    int32_t  startVertex;
    uint32_t numInstances;
    uint32_t startInstance;
};

event DrawIndexedInstancedEvent
{
    uint32_t drawId;
    uint32_t topology;
    uint32_t numIndices;
    int32_t  indexOffset;
    int32_t  baseVertex;
    uint32_t numInstances;
    uint32_t startInstance;
};

event DispatchEvent
{
    uint32_t drawId;
    uint32_t threadGroupCountX;
    uint32_t threadGroupCountY;
    uint32_t threadGroupCountZ;
};

event FrameEndEvent
{
    uint32_t frameId;
    uint32_t nextDrawId;
};

///@brief API Stat: Split draw event for DrawInstanced. In certain cases, Rasty can split draws up into smaller draws.
event DrawInstancedSplitEvent
{
    uint32_t drawId;
};

///@brief API Stat: Split draw event for DrawIndexedInstanced.
event DrawIndexedInstancedSplitEvent
{
    uint32_t drawId;
};

///@brief API Stat: Synchonization event.
event SwrSyncEvent
{
    uint32_t drawId;
};

///@brief API Stat: Invalidate hot tiles (i.e. tile cache)
event SwrInvalidateTilesEvent
{
    uint32_t drawId;
};

///@brief API Stat: Invalidate and discard hot tiles within pixel region
event SwrDiscardRectEvent
{
    uint32_t drawId;
};

///@brief API Stat: Flush tiles out to memory that is typically owned by driver (e.g. Flush RT cache)
event SwrStoreTilesEvent
{
    uint32_t drawId;
};

event FrontendStatsEvent
{
    uint32_t drawId;
    uint64_t IaVertices;
    uint64_t IaPrimitives;
    uint64_t VsInvocations;
    uint64_t HsInvocations;
    uint64_t DsInvocations;
    uint64_t GsInvocations;
    uint64_t GsPrimitives;
    uint64_t CInvocations;
    uint64_t CPrimitives;
    uint64_t SoPrimStorageNeeded0;
    uint64_t SoPrimStorageNeeded1;
    uint64_t SoPrimStorageNeeded2;
    uint64_t SoPrimStorageNeeded3;
    uint64_t SoNumPrimsWritten0;
    uint64_t SoNumPrimsWritten1;
    uint64_t SoNumPrimsWritten2;
    uint64_t SoNumPrimsWritten3;
};

event BackendStatsEvent
{
    uint32_t drawId;
    uint64_t DepthPassCount;
    uint64_t PsInvocations;
    uint64_t CsInvocations;

};

event EarlyDepthStencilInfoSingleSample
{
    uint64_t depthPassMask;
    uint64_t stencilPassMask;
    uint64_t coverageMask;
};

event EarlyDepthStencilInfoSampleRate
{
    uint64_t depthPassMask;
    uint64_t stencilPassMask;
    uint64_t coverageMask;
};

event EarlyDepthStencilInfoNullPS
{
    uint64_t depthPassMask;
    uint64_t stencilPassMask;
    uint64_t coverageMask;
};

event LateDepthStencilInfoSingleSample
{
    uint64_t depthPassMask;
    uint64_t stencilPassMask;
    uint64_t coverageMask;
};

event LateDepthStencilInfoSampleRate
{
    uint64_t depthPassMask;
    uint64_t stencilPassMask;
    uint64_t coverageMask;
};

event LateDepthStencilInfoNullPS
{
    uint64_t depthPassMask;
    uint64_t stencilPassMask;
    uint64_t coverageMask;
};

event EarlyDepthInfoPixelRate
{
    uint64_t depthPassCount;
    uint64_t activeLanes;
};


event LateDepthInfoPixelRate
{
    uint64_t depthPassCount;
    uint64_t activeLanes;
};


event BackendDrawEndEvent
{
    uint32_t drawId;
};

event FrontendDrawEndEvent
{
    uint32_t drawId;
};

event EarlyZSingleSample
{
    uint32_t drawId;
    uint64_t passCount;
    uint64_t failCount;
};	

event LateZSingleSample
{
    uint32_t drawId;
    uint64_t passCount;
    uint64_t failCount;
};

event EarlyStencilSingleSample
{
    uint32_t drawId; 
    uint64_t passCount;
    uint64_t failCount;
};

event LateStencilSingleSample
{
    uint32_t drawId; 
    uint64_t passCount;
    uint64_t failCount;
};

event EarlyZSampleRate
{
    uint32_t drawId;
    uint64_t passCount;
    uint64_t failCount;
};	

event LateZSampleRate
{
    uint32_t drawId;
    uint64_t passCount;
    uint64_t failCount;
};

event EarlyStencilSampleRate
{
    uint32_t drawId; 
    uint64_t passCount;
    uint64_t failCount;
};

event LateStencilSampleRate
{
    uint32_t drawId; 
    uint64_t passCount;
    uint64_t failCount;
};

event EarlyZNullPS
{
    uint32_t drawId;
    uint64_t passCount;
    uint64_t failCount;
};

event EarlyStencilNullPS
{
    uint32_t drawId; 
    uint64_t passCount;
    uint64_t failCount;
};

event EarlyZPixelRate
{
    uint32_t drawId;
    uint64_t passCount;
    uint64_t failCount;
};

event LateZPixelRate
{
    uint32_t drawId;
    uint64_t passCount;
    uint64_t failCount;
};


event EarlyOmZ
{
    uint32_t drawId;
    uint64_t passCount;
    uint64_t failCount;
};

event EarlyOmStencil
{
    uint32_t drawId;
    uint64_t passCount;
    uint64_t failCount;
};

event LateOmZ
{
    uint32_t drawId;
    uint64_t passCount;
    uint64_t failCount;
};

event LateOmStencil
{
    uint32_t drawId;
    uint64_t passCount;
    uint64_t failCount;
};

event GSPrimInfo
{
    uint64_t inputPrimCount;
    uint64_t primGeneratedCount;
    uint64_t vertsInput;
};

event GSInputPrims
{
    uint32_t drawId;
    uint64_t inputPrimCount;
};

event GSPrimsGen
{
    uint32_t drawId;
    uint64_t primGeneratedCount;
};

event GSVertsInput
{
    uint32_t drawId;
    uint64_t vertsInput;
};

event ClipVertexCount
{
    uint64_t vertsPerPrim;
    uint64_t primMask;
};

//REMOVE AND REPLACE
event FlushVertClip
{
    uint32_t drawId;
};

event VertsClipped
{
    uint32_t drawId;
    uint64_t clipCount;
};

event TessPrimCount
{
    uint64_t primCount;
};

//REMOVE AND REPLACE
event TessPrimFlush
{
    uint32_t drawId;
};

event TessPrims
{
    uint32_t drawId;
    uint64_t primCount;
};
