# $Id$
## @file
# Makefile for the VBox Main module.
#

#
# Copyright (C) 2004-2018 Oracle Corporation
#
# This file is part of VirtualBox Open Source Edition (OSE), as
# available from http://www.virtualbox.org. This file is free software;
# you can redistribute it and/or modify it under the terms of the GNU
# General Public License (GPL) as published by the Free Software
# Foundation, in version 2 as it comes in the "COPYING" file of the
# VirtualBox OSE distribution. VirtualBox OSE is distributed in the
# hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
#

SUB_DEPTH = ../../..
include $(KBUILD_PATH)/subheader.kmk

#
# Make sure our Config.kmk is included.
#
ifndef VBOX_MAIN_CONFIG_KMK_INCLUDED
 include $(PATH_SUB_CURRENT)/Config.kmk
endif

#
# Include sub-makefile(s).
#
ifndef VBOX_ONLY_EXTPACKS
 ifdef VBOX_WITH_WEBSERVICES
  include $(PATH_SUB_CURRENT)/webservice/Makefile.kmk
 endif
 include $(PATH_SUB_CURRENT)/testcase/Makefile.kmk
 include $(PATH_SUB_CURRENT)/cbinding/Makefile.kmk
 include $(PATH_SUB_CURRENT)/UnattendedTemplates/Makefile.kmk
endif


#
# Targets and globals (bit of a mess...)
#
VBOX_PATH_MAIN_SRC := $(PATH_SUB_CURRENT)

ifdef VBOX_ONLY_SDK
 # I'm Evil! Dr. Evil.
 VBoxCOM_0_OUTDIR = $(PATH_TARGET)/VBoxCOM
 BLDDIRS += $(VBoxCOM_0_OUTDIR) $(PATH_STAGE_BIN)/components
 include $(KBUILD_PATH)/tools/$(VBOX_VCC_TOOL).kmk # For the idl /cpp statement.
 include $(KBUILD_PATH)/sdks/$(VBOX_WINPSDK).kmk
endif # !VBOX_ONLY_SDK


# Construct VBOX_MAIN_DEFS
## @todo eliminate or expand VBOX_MAIN_DEFS.
VBOX_MAIN_DEFS   =
ifneq ($(KBUILD_TARGET),win)
 ifndef VBOX_WITH_XPCOM
  $(error "VBox: VBOX_WITH_XPCOM isn't defined")
 endif
 VBOX_MAIN_DEFS += VBOX_WITH_GENERIC_SESSION_WATCHER
endif
VBOX_MAIN_DEFS += \
	$(if $(VBOX_WITH_RAW_MODE),VBOX_WITH_RAW_MODE,) \
	$(if $(VBOX_WITH_RAW_RING1),VBOX_WITH_RAW_RING1,) \
	$(if $(VBOX_WITH_VMSVGA),VBOX_WITH_VMSVGA,) \
	$(if $(VBOX_WITH_VMSVGA3D),VBOX_WITH_VMSVGA3D,) \
	$(if $(VBOX_WITH_NETFLT),VBOX_WITH_NETFLT,) \
	$(if $(VBOX_WITH_COPYTOGUEST),VBOX_WITH_COPYTOGUEST,) \
	$(if $(VBOX_WITH_CROGL),VBOX_WITH_CROGL,) \
	$(if $(VBOX_WITH_CRHGSMI),VBOX_WITH_CRHGSMI,) \
	$(if $(VBOX_WITH_GUEST_PROPS),VBOX_WITH_GUEST_PROPS,) \
	$(if $(VBOX_WITH_GUEST_PROPS_RDONLY_GUEST),VBOX_WITH_GUEST_PROPS_RDONLY_GUEST,) \
	$(if $(VBOX_WITH_GUEST_CONTROL),VBOX_WITH_GUEST_CONTROL,) \
	$(if $(VBOX_WITH_USB_CARDREADER),VBOX_WITH_USB_CARDREADER,) \
	$(if $(VBOX_WITH_USB_CARDREADER_TEST),VBOX_WITH_USB_CARDREADER_TEST,) \
	$(if $(VBOX_WITH_HOSTNETIF_API),VBOX_WITH_HOSTNETIF_API,) \
	$(if $(VBOX_WITH_MIDL_PROXY_STUB),VBOX_WITH_MIDL_PROXY_STUB,) \
	$(if $(VBOX_WITH_SDS),VBOX_WITH_SDS,) \
	$(if $(VBOX_WITH_CLOUD_PROVIDERS_NO_COMMANDS),VBOX_WITH_CLOUD_PROVIDERS_NO_COMMANDS,)

# Unconditionally enable the new semaphore key generation code
VBOX_MAIN_DEFS += VBOX_WITH_NEW_SYS_V_KEYGEN

VBOX_IDL_FILE.MSCOM    = $(VBOX_PATH_SDK)/bindings/mscom/idl/VirtualBox.idl
VBOX_IDL_FILE.XPCOM    = $(VBOX_PATH_SDK)/bindings/xpcom/idl/VirtualBox_XPCOM.idl

VBOX_IDL_TYPELIB.XPCOM = $(PATH_STAGE_BIN)/components/VirtualBox_XPCOM.xpt
VBOX_IDL_HEADER.XPCOM  = $(VBOX_PATH_SDK)/bindings/xpcom/include/VirtualBox_XPCOM.h

# The MS COM specific stuff.
if defined(VBOX_ONLY_SDK) || "$(KBUILD_TARGET)" == "win"
 OTHERS         += \
	$(VBOX_IDL_FILE.MSCOM)
 OTHER_CLEAN    += \
	$(VBOX_IDL_FILE.MSCOM)

 INSTALLS += VBox-mscom-bindings-include VBox-mscom-bindings-lib
 VBox-mscom-bindings-include_INST = $(INST_SDK)bindings/mscom/include/
 VBox-mscom-bindings-include_MODE = a+r,u+w
 VBox-mscom-bindings-include_SOURCES = $(VBoxCOM_0_OUTDIR)/VirtualBox.h
 VBox-mscom-bindings-include_CLEAN = $(VBoxCOM_0_OUTDIR)/VirtualBox.h
 VBox-mscom-bindings-lib_INST = $(INST_SDK)bindings/mscom/lib/
 VBox-mscom-bindings-lib_MODE = a+r,u+w
 VBox-mscom-bindings-lib_SOURCES = $(VBoxCOM_0_OUTDIR)/VirtualBox_i.c \
	$(VBoxCOM_0_OUTDIR)/VirtualBox.tlb
 VBox-mscom-bindings-lib_CLEAN = $(VBoxCOM_0_OUTDIR)/VirtualBox_i.c \
	$(VBoxCOM_0_OUTDIR)/VirtualBox.tlb

 BLDDIRS += $(VBOX_PATH_SDK)/bindings/mscom/idl
endif

# The XPCOM specific stuff.
# if defined(VBOX_ONLY_SDK) || "$(KBUILD_TARGET)" != "win" -- does not build on Windows
if "$(KBUILD_TARGET)" != "win"
 OTHERS         += $(VBOX_IDL_FILE.XPCOM) $(VBOX_IDL_TYPELIB.XPCOM) $(VBOX_IDL_HEADER.XPCOM)
 OTHER_CLEAN    += \
	$(VBOX_IDL_FILE.XPCOM) \
	$(VBOX_IDL_HEADER.XPCOM) \
	$(VBOX_IDL_TYPELIB.XPCOM)

 INSTALLS += VBox-xpcom-bindings-lib
 VBox-xpcom-bindings-lib_INST = $(INST_SDK)bindings/xpcom/lib/
 VBox-xpcom-bindings-lib_MODE = a+r,u+w
 VBox-xpcom-bindings-lib_SOURCES = $(VBoxCOM_0_OUTDIR)/VirtualBox_XPCOM_i.c=>VirtualBox_i.c
 VBox-xpcom-bindings-lib_CLEAN = $(VBoxCOM_0_OUTDIR)/VirtualBox_XPCOM_i.c

 VBOX_MAIN_PREREQS += $(VBOX_IDL_TYPELIB.XPCOM) $(VBOX_IDL_HEADER.XPCOM)
 BLDDIRS += \
	$(VBOX_PATH_SDK)/bindings/xpcom/idl \
	$(VBOX_PATH_SDK)/bindings/xpcom/include
 # disable VBoxSDS for XPCOM
 override VBOX_WITH_SDS =
endif # xpcom


#
# Strip documentation from source XIDL so that we don't get a full
# recompile every time a comma in the documentation is changed.
#
$(call KB_FN_AUTO_CMD_DEPS,$(VBOX_XIDL_FILE).ts)
$(VBOX_XIDL_FILE).ts +| $(VBOX_XIDL_FILE): \
		$(VBOX_XIDL_FILE_SRC) \
		$(VBOX_PATH_MAIN_SRC)/idl/docstrip.xsl \
		| $$(dir $$@)
	$(call KB_FN_AUTO_CMD_DEPS_COMMANDS)
	$(QUIET)$(VBOX_XSLTPROC) -o $(VBOX_XIDL_FILE).ts-tmp $(VBOX_PATH_MAIN_SRC)/idl/docstrip.xsl $(VBOX_XIDL_FILE_SRC)
	$(QUIET)$(SED)  -e 's/ *$(DOLLAR)//g'  -e '/^$(DOLLAR)/d' --output $(VBOX_XIDL_FILE).ts $(VBOX_XIDL_FILE).ts-tmp
	$(QUIET)$(RM) -- $(VBOX_XIDL_FILE).ts-tmp
	$(QUIET)$(CP) --changed -fv -- $(VBOX_XIDL_FILE).ts $(VBOX_XIDL_FILE)

OTHER_CLEAN += $(VBOX_XIDL_FILE) $(VBOX_XIDL_FILE).ts


#
# The Main API documentation
#
VBOX_MAIN_DOC_DIR = $(VBOX_PATH_SDK)/docs
BLDDIRS += $(VBOX_MAIN_DOC_DIR)

$(PATH_TARGET)/docs.Main: \
		$(VBOX_PATH_MAIN_SRC)/Doxyfile.Main \
		$(VBOX_PATH_MAIN_SRC)/idl/doxygen.xsl \
		$(VBOX_XIDL_FILE_SRC) \
		| $(PATH_TARGET)/ \
		$(VBOX_MAIN_DOC_DIR)/
	$(call MSG_TOOL,xsltproc,doxygen input,$<,$@)
	$(QUIET)$(RM) -f $(wildcard $(VBOX_MAIN_DOC_DIR)/html/*) $(PATH_TARGET)/docs.Main
	$(QUIET)$(VBOX_XSLTPROC) -o $(PATH_TARGET)/VirtualBox.idl $(VBOX_PATH_MAIN_SRC)/idl/doxygen.xsl $(VBOX_XIDL_FILE_SRC)
	$(QUIET)$(REDIRECT) -E 'DOCDIR=$(VBOX_MAIN_DOC_DIR)' -E 'PATH_TARGET=$(PATH_TARGET)' -E 'PATH_CHM=$(subst /,\,$(VBOX_MAIN_DOC_DIR)/VirtualBoxAPI.chm)' \
		-- doxygen $(VBOX_PATH_MAIN_SRC)/Doxyfile.Main
	$(QUIET)$(TEST) -s "$(PATH_TARGET)/Main.err" -- $(ECHO_EXT) ">>>>>>>>>>>>>>>>>>>> Main.err: >>>>>>>>>>>>>>>>>>>>>>>>"
	$(QUIET)$(TEST) -s "$(PATH_TARGET)/Main.err" -- $(CAT) "$(PATH_TARGET)/Main.err"
	$(QUIET)$(TEST) -s "$(PATH_TARGET)/Main.err" -- $(ECHO_EXT) "<<<<<<<<<<<<<<<<<<<< Main.err <<<<<<<<<<<<<<<<<<<<<<<<<"
	$(QUIET)$(TEST) -s "$(PATH_TARGET)/Main.err" -- $(ECHO_EXT) "===> **************************************************"
	$(QUIET)$(TEST) -s "$(PATH_TARGET)/Main.err" -- $(ECHO_EXT) "===> Please fix above doxygen errors/warnings listed in"
	$(QUIET)$(TEST) -s "$(PATH_TARGET)/Main.err" -- $(ECHO_EXT) "===> $(PATH_TARGET)/Main.err"
	$(QUIET)$(TEST) -s "$(PATH_TARGET)/Main.err" -- $(ECHO_EXT) "===> **************************************************"
	-$(EXEC_X86_WIN32) $(VBOX_PATH_HTML_HELP_WORKSHOP)/hhc.exe $(subst /,\\,$(VBOX_MAIN_DOC_DIR)/html/index.hhp)
	$(APPEND) $(PATH_TARGET)/docs.Main
# aliases
docs.main docs.Main: $(PATH_TARGET)/docs.Main
if !defined(VBOX_ONLY_DOCS) && defined(VBOX_WITH_ALL_DOXYGEN_TARGETS)
docs:                $(PATH_TARGET)/docs.Main
else
docs:
endif


ifndef VBOX_ONLY_SDK
 #
 # Generate library with API class wrappers from the XIDL file.
 #
 LIBRARIES += VBoxAPIWrap
 VBoxAPIWrap_TEMPLATE        = VBoxMainLib
 ifeq ($(KBUILD_TARGET),win)
  VBoxAPIWrap_USES           = vccprecomp
  VBoxAPIWrap_PCH_HDR       := $(PATH_SUB_CURRENT)/src-all/win/VBoxAPIWrap-precomp_vcc.h
 endif
 VBoxAPIWrap_SOURCES         = \
 	$(VBoxAPIWrap_0_OUTDIR)/VBoxAPI.d \
 	$(if-expr defined(VBOX_ONLY_EXTPACKS) \
	, $(addprefix $(VBoxAPIWrap_0_OUTDIR)/,$(filter Cloud%, $(notdir $(VBOX_MAIN_APIWRAPPER_GEN_SRCS)))) \
	, $(VBOX_MAIN_APIWRAPPER_GEN_SRCS))
 VBoxAPIWrap_INTERMEDIATES   = $(VBOX_MAIN_APIWRAPPER_GEN_HDRS)
 VBoxAPIWrap_DEFS.win.x86   += _WIN32_WINNT=0x0500
 VBoxAPIWrap_DEFS.win.amd64 += _WIN32_WINNT=0x0510
 VBoxAPIWrap_INCS           += \
 	include
 VBoxAPIWrap_CLEAN           = \
 	$(wildcard $(VBoxAPIWrap_0_OUTDIR)/*.cpp) \
 	$(wildcard $(VBoxAPIWrap_0_OUTDIR)/*.h) \
 	$(VBoxAPIWrap_0_OUTDIR)/VBoxAPI.d.ts \
 	$(VBoxAPIWrap_0_OUTDIR)/VBoxAPI.d \
 	$(VBoxAPIWrap_0_OUTDIR)/apiwrappers-headers \
 	$(VBoxAPIWrap_0_OUTDIR)/apiwrappers-sources-even \
 	$(VBoxAPIWrap_0_OUTDIR)/apiwrappers-sources-odd

 # Two VBox variables used here and/or in the rules generating wrappers.
 VBoxAPIWrap_VBOX_XSLT       = \
 	$(VBOX_PATH_MAIN_SRC)/idl/apiwrap-server.xsl


 # This include file (generated at the bottom of this file), defines
 # VBOX_MAIN_APIWRAPPER_GEN_SRCS and VBOX_MAIN_APIWRAPPER_GEN_HDRS.
 VBoxAPIWrap_VBOX_KMK_FILE = $(PATH_OUT)/vboxapiwrap.kmk
 include $(VBoxAPIWrap_VBOX_KMK_FILE)

 ifdef VBOX_WITH_32_ON_64_MAIN_API
  LIBRARIES += VBoxAPIWrap-x86
  VBoxAPIWrap-x86_TEMPLATE = VBoxMainLib-x86
  VBoxAPIWrap-x86_EXTENDS  = VBoxAPIWrap
  VBoxAPIWrap-x86_DTRACE_HDR_FLAGS = -32 # ugly, should be fixed in the tool in Config.kmk
  ifeq ($(KBUILD_TARGET),win) ## @todo fix inheritance
   VBoxAPIWrap-x86_USES     = vccprecomp
   VBoxAPIWrap-x86_PCH_HDR := $(PATH_SUB_CURRENT)/src-all/win/VBoxAPIWrap-precomp_vcc.h
  endif
 endif

endif # !VBOX_ONLY_SDK

#
# Some SDK bit.
#
INSTALLS += VBox-main-xidl
VBox-main-xidl_INST = $(INST_SDK)bindings/
VBox-main-xidl_MODE = a+r,u+w
VBox-main-xidl_SOURCES = $(VBOX_XIDL_FILE_SRC)

if defined(VBOX_WITH_PYTHON) && !defined(VBOX_ONLY_EXTPACKS)
 INSTALLS += VBox-python-glue
 VBox-python-glue_INST = $(INST_SDK)installer/vboxapi/
 VBox-python-glue_MODE = a+r,u+w
 VBox-python-glue_SOURCES = \
 	glue/vboxapi.py=>__init__.py \
 	$(VBox-python-glue_0_OUTDIR)/VirtualBox_constants.py
 VBox-python-glue_CLEAN = \
 	$(VBox-python-glue_0_OUTDIR)/VirtualBox_constants.py
 $(call KB_FN_DO_PASS0_ON_TARGET,VBox-python-glue)
 $(call KB_FN_AUTO_CMD_DEPS,$(VBox-python-glue_0_OUTDIR)/VirtualBox_constants.py)
 $(VBox-python-glue_0_OUTDIR)/VirtualBox_constants.py:  \
		$(VBOX_PATH_MAIN_SRC)/glue/constants-python.xsl \
		$(VBOX_XIDL_FILE) \
		| $$(dir $$@)
	$(call KB_FN_AUTO_CMD_DEPS_COMMANDS)
	$(call MSG_TOOL,xsltproc,Python constants,$<,$@)
	$(QUIET)$(VBOX_XSLTPROC) -o $@ $(VBOX_PATH_MAIN_SRC)/glue/constants-python.xsl $(VBOX_XIDL_FILE)
endif # VBOX_WITH_PYTHON && !VBOX_ONLY_EXTPACKS

if !defined(VBOX_ONLY_SDK) && !defined(VBOX_ONLY_EXTPACKS) # Note this goes on for *very* long

#
# Generate SchemaDefs.h and SchemaDefs.cpp from XML Schema
# These two files are used by both VBoxC and VBoxSVC.
#
BLDDIRS += $(PATH_TARGET)/Main

testschemadefs: $(VBOX_XML_SCHEMADEFS_H) $(VBOX_XML_SCHEMADEFS_CPP)


#
# VBoxSDS executable
#
if defined(VBOX_WITH_SDS) && "$(KBUILD_TARGET)" == "win"
 PROGRAMS += VBoxSDS
 VBoxSDS_TEMPLATE = VBOXMAINEXE
 VBoxSDS_DEFS.win += VBOX_COM_OUTOFPROC_MODULE
 VBoxSDS_DEFS.win += _WIN32_WINNT=0x0510
 VBoxSDS_INCS = \
 	include \
 	$(VBoxSDS_0_OUTDIR) \
 	$(VBOX_MAIN_APIWRAPPER_INCS)
 VBoxSDS_INCS.win = \
 	$(VBoxCOM_0_OUTDIR)
 VBoxSDS_LIBS += \
 	$(PATH_STAGE_LIB)/VBoxAPIWrap$(VBOX_SUFF_LIB)
 VBoxSDS_INTERMEDIATES = \
 	$(VBOX_MAIN_PREREQS) \
 	$(VBOX_MAIN_APIWRAPPER_GEN_HDRS)
 VBoxSDS_SOURCES = \
 	src-all/Global.cpp \
 	src-all/AutoCaller.cpp \
 	src-all/VirtualBoxBase.cpp \
 	src-all/VirtualBoxErrorInfoImpl.cpp \
 	src-all/VirtualBoxClientListImpl.cpp \
 	src-global/VirtualBoxSDSImpl.cpp
 VBoxSDS_SOURCES.win = \
 	src-global/win/VBoxSDS.cpp \
 	src-global/win/VBoxSDS.rc
 $(call KB_FN_DO_PASS0_ON_TARGET,VBoxSDS) # Sets VBoxSDS_0_OUTDIR

 src-global/win/VBoxSDS.rc_INCS  = $(VBoxSDS_0_OUTDIR)
 src-global/win/VBoxSDS.rc_DEPS  = $(VBoxSDS_0_OUTDIR)/VBoxSDS-icon.rc #$(VBoxSDS_0_OUTDIR)/VBoxSDS.rgs
 src-global/win/VBoxSDS.rc_CLEAN = $(VBoxSDS_0_OUTDIR)/VBoxSDS-icon.rc #$(VBoxSDS_0_OUTDIR)/VBoxSDS.rgs

 $(call KB_FN_AUTO_CMD_DEPS,$(VBoxSDS_0_OUTDIR)/VBoxSDS-icon.rc)
 $(VBoxSDS_0_OUTDIR)/VBoxSDS-icon.rc: $(VBOX_WINDOWS_ICON_FILE) | $$(dir $$@)
	$(call KB_FN_AUTO_CMD_DEPS_COMMANDS)
	$(APPEND) -t $@ '1 ICON DISCARDABLE "$(subst /,\\,$(VBOX_WINDOWS_ICON_FILE))"'

# $(call KB_FN_AUTO_CMD_DEPS,$(VBoxSDS_0_OUTDIR)/VBoxSDS.rgs)
# $(VBoxSDS_0_OUTDIR)/VBoxSDS.rgs: $(VBOX_PATH_MAIN_SRC)/src-all/win/VirtualBox_rgs.xsl $(VBOX_XIDL_FILE) | $$(dir $$@)
#	$(call KB_FN_AUTO_CMD_DEPS_COMMANDS)
#	$(VBOX_XSLTPROC) \
#		--stringparam Application "VirtualBox System" \
#		--stringparam Module VBoxSDS \
#		-o $@ \
#		$(VBOX_PATH_MAIN_SRC)/src-all/win/VirtualBox_rgs.xsl \
#		$(VBOX_XIDL_FILE)
#
endif #if defined(VBOX_WITH_SDS) && "$(KBUILD_TARGET)" == "win"

#
# VBoxSVC executable
#
PROGRAMS += VBoxSVC
VBoxSVC_TEMPLATE = VBOXMAINEXE
if defined(VBOX_WITH_PRECOMPILED_HEADERS) && "$(KBUILD_TARGET)" == "win"
 VBoxSVC_USES    += vccprecomp
 VBoxSVC_PCH_HDR := $(PATH_SUB_CURRENT)/src-server/win/precomp_vcc.h
endif
VBoxSVC_DEFS = \
	VBOX_MAIN_SETTINGS_ADDONS \
	IN_VMM_STATIC \
	$(VBOX_MAIN_DEFS) \
	$(if $(VBOX_WITH_VBOXSDL),VBOX_WITH_VBOXSDL,) \
	$(if $(VBOX_WITH_HEADLESS),VBOX_WITH_HEADLESS,) \
	$(if $(VBOX_WITH_QTGUI),VBOX_WITH_QTGUI,) \
	$(if $(VBOX_GUI_WITH_SHARED_LIBRARY),VBOX_GUI_WITH_SHARED_LIBRARY,) \
	$(if $(VBOX_WITH_HGCM),VBOX_WITH_HGCM,) \
	$(if $(VBOX_WITH_AUDIO_OSS),VBOX_WITH_AUDIO_OSS,) \
	$(if $(VBOX_WITH_AUDIO_ALSA),VBOX_WITH_AUDIO_ALSA,) \
	$(if $(VBOX_WITH_AUDIO_PULSE),VBOX_WITH_AUDIO_PULSE,) \
	$(if $(VBOX_WITH_AUDIO_DEBUG),VBOX_WITH_AUDIO_DEBUG,) \
	$(if $(VBOX_WITH_AUDIO_VALIDATIONKIT),VBOX_WITH_AUDIO_VALIDATIONKIT,) \
	$(if $(VBOX_WITH_AUDIO_VIDEOREC),VBOX_WITH_AUDIO_VIDEOREC,) \
	$(if $(VBOX_WITH_VIDEOREC),VBOX_WITH_VIDEOREC,) \
	$(if $(VBOX_WITH_AUDIO_VRDE),VBOX_WITH_AUDIO_VRDE,) \
	$(if $(VBOX_WITH_E1000),VBOX_WITH_E1000,) \
	$(if $(VBOX_WITH_VIRTIO),VBOX_WITH_VIRTIO,) \
	$(if $(VBOX_WITH_AHCI),VBOX_WITH_AHCI,) \
	$(if $(VBOX_WITH_LSILOGIC),VBOX_WITH_LSILOGIC,) \
	$(if $(VBOX_WITH_LINUX_COMPILER_H),VBOX_WITH_LINUX_COMPILER_H,) \
	$(if $(VBOX_WITH_RESOURCE_USAGE_API),VBOX_WITH_RESOURCE_USAGE_API,) \
	$(if $(VBOX_WITH_UNATTENDED),VBOX_WITH_UNATTENDED,) \
	$(if $(VBOX_WITH_PDM_ASYNC_COMPLETION),VBOX_WITH_PDM_ASYNC_COMPLETION,) \
	$(if $(VBOX_WITH_DBUS),VBOX_WITH_DBUS,) \
	$(if $(VBOX_WITH_DBUS),$(if $(VBOX_USB_WITH_DBUS),VBOX_USB_WITH_DBUS,),) \
	$(if $(VBOX_USB_WITH_SYSFS),VBOX_USB_WITH_SYSFS,) \
	$(if $(VBOX_USB_WITH_INOTIFY),VBOX_USB_WITH_INOTIFY,) \
	$(if $(VBOX_WITH_LIVE_MIGRATION),VBOX_WITH_LIVE_MIGRATION,) \
	$(if $(VBOX_WITH_EXTPACK),VBOX_WITH_EXTPACK,) \
	$(if $(VBOX_WITH_VUSB),VBOX_WITH_VUSB,) \
	$(if $(VBOX_WITH_PCI_PASSTHROUGH),VBOX_WITH_PCI_PASSTHROUGH,) \
	$(if $(VBOX_WITH_NAT_SERVICE),VBOX_WITH_NAT_SERVICE,) \
	$(if $(VBOX_WITH_CROGL),VBOX_WITH_CROGL,) \
	$(if $(VBOX_WITH_CRHGSMI),VBOX_WITH_CRHGSMI,) \
	$(if-expr defined(VBOX_WITH_SDS),VBOX_WITH_SDS,)
ifdef VBOX_WITH_USB
 VBoxSVC_DEFS += \
	VBOX_WITH_USB \
	$(if $(VBOX_WITH_EHCI),VBOX_WITH_EHCI,) \
	$(if $(VBOX_WITH_NEW_USB_CODE_ON_DARWIN),VBOX_WITH_NEW_USB_CODE_ON_DARWIN,)
endif
VBoxSVC_DEFS.win += VBOX_COM_OUTOFPROC_MODULE
VBoxSVC_DEFS.win += _WIN32_WINNT=0x0510
# Try to load and use libhal at runtime for probing removable media
# VBoxSVC_DEFS.linux += VBOX_USE_LIBHAL
VBoxSVC_DEFS.solaris += VBOX_USE_LIBHAL

if $(KBUILD_TARGET) != "win" && $(VBOX_GCC_VERSION_CXX) >= 40900 # gcc 4.9.x (4.8.x is causing endless RT_ELEMENT trouble)
 VBoxSVC_CXXFLAGS = -Wunused -Wconversion
endif

VBoxSVC_INCS = \
	include \
	$(VBoxSVC_0_OUTDIR) \
	$(dir $(VBOX_XML_SCHEMADEFS_H)) \
	$(VBOX_MAIN_APIWRAPPER_INCS) \
	. \
	$(VBOX_GRAPHICS_INCS)
VBoxSVC_INCS.win = \
	$(VBoxCOM_0_OUTDIR)
ifdef VBOX_WITH_USB
 VBoxSVC_INCS.os2 = \
	$(PATH_ROOT)/src/VBox/HostDrivers/VBoxUSB/os2
endif

VBoxSVC_LIBS += \
	$(PATH_STAGE_LIB)/VBoxAPIWrap$(VBOX_SUFF_LIB) \
	$(PATH_STAGE_LIB)/SSMStandalone$(VBOX_SUFF_LIB) \
	$(LIB_DDU)

VBoxSVC_SDKS = VBOX_LIBPNG VBOX_ZLIB
VBoxSVC_LIBS.solaris = \
	adm \
	nsl \
	devinfo \
	socket \
	$(LIB_VMM)

VBoxSVC_LIBS.win += \
	$(PATH_SDK_$(VBOX_WINPSDK)_LIB)/dnsapi.lib

VBoxSVC_INTERMEDIATES = \
	$(VBOX_MAIN_PREREQS) \
	$(VBOX_XML_SCHEMADEFS_H) \
	$(VBOX_AUTOGEN_EVENT_H) \
	$(VBOX_MAIN_APIWRAPPER_GEN_HDRS)

VBoxSVC_SOURCES = \
	$(VBoxAPIWrap_0_OUTDIR)/VBoxAPI.d \
	src-all/AuthLibrary.cpp \
	src-all/DisplayPNGUtil.cpp \
	src-all/DisplayResampleImage.cpp \
	src-all/DisplayUtils.cpp \
	src-all/EventImpl.cpp \
	src-all/Global.cpp \
	src-all/HashedPw.cpp \
	src-all/Logging.cpp \
	src-all/PCIDeviceAttachmentImpl.cpp \
	src-all/ProgressImpl.cpp \
	src-all/QMTranslatorImpl.cpp \
	src-all/SecretKeyStore.cpp \
	src-all/SharedFolderImpl.cpp \
	src-all/AutoCaller.cpp \
	src-all/ThreadTask.cpp \
	src-all/VirtualBoxBase.cpp \
	src-all/VirtualBoxErrorInfoImpl.cpp \
	$(if $(VBOX_WITH_EXTPACK),src-all/ExtPackManagerImpl.cpp src-all/ExtPackUtil.cpp,) \
	src-server/CertificateImpl.cpp \
	src-server/ApplianceImpl.cpp \
	src-server/ApplianceImplExport.cpp \
	src-server/ApplianceImplImport.cpp \
	src-server/AudioAdapterImpl.cpp \
	src-server/BandwidthControlImpl.cpp \
	src-server/BandwidthGroupImpl.cpp \
	src-server/BIOSSettingsImpl.cpp \
	src-server/ClientWatcher.cpp \
	src-server/ClientToken.cpp \
	src-server/CloudProviderManagerImpl.cpp \
	src-server/DataStreamImpl.cpp \
	src-server/DHCPServerImpl.cpp \
	src-server/NetworkServiceRunner.cpp \
	src-server/NATNetworkImpl.cpp \
	src-server/GuestOSTypeImpl.cpp \
	src-server/HostDnsService.cpp \
	src-server/HostImpl.cpp \
	src-server/HostNetworkInterfaceImpl.cpp \
	src-server/HostPower.cpp \
	src-server/HostVideoInputDeviceImpl.cpp \
	src-server/MachineImpl.cpp \
	src-server/MachineImplCloneVM.cpp \
	src-server/MachineImplMoveVM.cpp \
	src-server/Matching.cpp \
	src-server/MediumAttachmentImpl.cpp \
	src-server/MediumFormatImpl.cpp \
	src-server/MediumImpl.cpp \
	src-server/MediumLock.cpp \
	src-server/MediumIOImpl.cpp \
	src-server/NATEngineImpl.cpp \
	src-server/NetworkAdapterImpl.cpp \
	src-server/ParallelPortImpl.cpp \
	src-server/ProgressProxyImpl.cpp \
	src-server/SerialPortImpl.cpp \
	src-server/SnapshotImpl.cpp \
	src-server/StorageControllerImpl.cpp \
	src-server/SystemPropertiesImpl.cpp \
	src-server/TokenImpl.cpp \
	$(if $(VBOX_WITH_UNATTENDED), \
	src-server/UnattendedImpl.cpp \
	src-server/UnattendedInstaller.cpp \
	src-server/UnattendedScript.cpp \
	,) \
	src-server/USBControllerImpl.cpp \
	src-server/USBDeviceFiltersImpl.cpp \
	src-server/VFSExplorerImpl.cpp \
	src-server/VirtualBoxImpl.cpp \
	src-server/VRDEServerImpl.cpp \
	src-server/generic/AutostartDb-generic.cpp \
	xml/ovfreader.cpp \
	xml/Settings.cpp \
	$(VBOX_XML_SCHEMADEFS_CPP) \
	$(VBOX_AUTOGEN_EVENT_CPP) \
	$(if $(VBOX_WITH_XPCOM),src-server/xpcom/server.cpp,)

src-server/ApplianceImplExport.cpp_DEFS = VBOX_SVN_REV=$(VBOX_SVN_REV)

ifn1of ($(KBUILD_TARGET), win darwin)
	VBoxSVC_SOURCES += $(PATH_ROOT)/src/VBox/Devices/Network/slirp/resolv_conf_parser.c
#	$(PATH_ROOT)/src/VBox/Devices/Network/slirp/resolv_conf_parser.c_DEFS += LOG_GROUP=LOG_GROUP_MAIN
endif

VBoxSVC_SOURCES.darwin = \
	src-server/darwin/iokit.cpp \
	src-server/darwin/HostPowerDarwin.cpp \
	src-server/darwin/HostDnsServiceDarwin.cpp

VBoxSVC_SOURCES.win = \
	src-server/win/svcmain.cpp \
	src-server/win/svchlp.cpp \
	src-server/win/HostPowerWin.cpp \
	src-server/win/VBoxSVC.rc \
	src-server/win/HostDnsServiceWin.cpp

VBoxSVC_SOURCES.linux = \
	src-server/linux/HostHardwareLinux.cpp \
	src-server/linux/HostDnsServiceLinux.cpp \
	$(if $(VBOX_WITH_DBUS),src-server/linux/HostPowerLinux.cpp) \
	src-server/HostDnsServiceResolvConf.cpp

VBoxSVC_SOURCES.solaris = \
	src-server/linux/vbox-libhal.cpp \
	src-server/solaris/DynLoadLibSolaris.cpp \
	src-server/HostDnsServiceResolvConf.cpp

VBoxSVC_SOURCES.os2 = \
	src-server/HostDnsServiceResolvConf.cpp

VBoxSVC_SOURCES.freebsd = \
	src-server/freebsd/HostHardwareFreeBSD.cpp \
	src-server/HostDnsServiceResolvConf.cpp


ifdef VBOX_WITH_USB
 ifdef VBOX_WITH_SYSFS_BY_DEFAULT
  src-server/linux/USBProxyBackendLinux.cpp_DEFS += VBOX_WITH_SYSFS_BY_DEFAULT
 endif
 VBoxSVC_SOURCES  += \
	src-server/USBDeviceFilterImpl.cpp \
	src-server/USBProxyService.cpp \
	src-server/USBProxyBackend.cpp \
	src-server/generic/USBProxyBackendUsbIp.cpp \
	src-server/HostUSBDeviceImpl.cpp
 VBoxSVC_SOURCES.darwin  +=  src-server/darwin/USBProxyBackendDarwin.cpp
 VBoxSVC_SOURCES.linux   +=   src-server/linux/USBProxyBackendLinux.cpp
 VBoxSVC_SOURCES.linux   +=   src-server/linux/USBGetDevices.cpp
 VBoxSVC_SOURCES.os2     +=     src-server/os2/USBProxyBackendOs2.cpp
 VBoxSVC_SOURCES.solaris += src-server/solaris/USBProxyBackendSolaris.cpp
 VBoxSVC_SOURCES.win     +=     src-server/win/USBProxyBackendWindows.cpp
 VBoxSVC_SOURCES.freebsd += src-server/freebsd/USBProxyBackendFreeBSD.cpp
endif

ifdef VBOX_WITH_NETFLT
 VBoxSVC_LIBS.win += \
	$(PATH_STAGE_LIB)/WinNetConfig$(VBOX_SUFF_LIB) \
	$(PATH_STAGE_LIB)/VBoxDrvCfg$(VBOX_SUFF_LIB) \
	$(PATH_SDK_$(VBOX_WINDDK)_LIB)/newdev.lib \
	$(PATH_TOOL_$(VBOX_VCC_TOOL)_LIB)/comsupp.lib \
	$(PATH_SDK_$(VBOX_WINPSDK)_LIB)/WbemUuid.Lib
endif
VBoxSVC_LDFLAGS.darwin    = -framework IOKit -framework SystemConfiguration

ifdef VBOX_WITH_CROGL
 VBoxSVC_LIBS += $(PATH_STAGE_LIB)/VBoxOGLTest$(VBOX_SUFF_LIB)
 VBoxSVC_LDFLAGS.darwin += -framework OpenGL
endif

ifeq ($(KBUILD_TYPE),debug)
 VBoxSVC_LDFLAGS.linux   += -rdynamic # for backtrace_symbols()
endif

ifdef VBOX_WITH_RESOURCE_USAGE_API
 VBoxSVC_SOURCES += \
	src-server/PerformanceImpl.cpp \
	src-server/Performance.cpp
 VBoxSVC_SOURCES.darwin  +=  src-server/darwin/PerformanceDarwin.cpp
 VBoxSVC_SOURCES.freebsd += src-server/freebsd/PerformanceFreeBSD.cpp
 VBoxSVC_SOURCES.linux   +=   src-server/linux/PerformanceLinux.cpp
 VBoxSVC_SOURCES.os2     +=     src-server/os2/PerformanceOs2.cpp
 VBoxSVC_SOURCES.solaris += src-server/solaris/PerformanceSolaris.cpp
 VBoxSVC_SOURCES.win     +=     src-server/win/PerformanceWin.cpp
 VBoxSVC_LDFLAGS.darwin  += -lproc
 VBoxSVC_LDFLAGS.solaris += -lkstat -lnvpair
 VBoxSVC_LDFLAGS.win     += psapi.lib powrprof.lib
endif

ifdef VBOX_WITH_HOSTNETIF_API
 VBoxSVC_SOURCES.win     +=     src-server/win/NetIf-win.cpp
 VBoxSVC_SOURCES.linux   +=   src-server/linux/NetIf-linux.cpp
 VBoxSVC_SOURCES.os2     +=     src-server/os2/NetIf-os2.cpp
 VBoxSVC_SOURCES.darwin  +=  src-server/darwin/NetIf-darwin.cpp
 VBoxSVC_SOURCES.solaris += src-server/solaris/NetIf-solaris.cpp
 VBoxSVC_SOURCES.freebsd += src-server/freebsd/NetIf-freebsd.cpp
 VBoxSVC_DEFS            += VBOX_WITH_HOSTNETIF_API
 if1of ($(KBUILD_TARGET), linux darwin solaris freebsd)
  VBoxSVC_SOURCES        += src-server/generic/NetIf-generic.cpp
 endif
endif

$(call KB_FN_DO_PASS0_ON_TARGET,VBoxSVC) # Sets VBoxSVC_0_OUTDIR

ifdef VBOX_WITH_MAIN_USB_ID_DATABASE # Generate a database of USB vendor IDs and device IDs.
 VBoxSVC_DEFS    += VBOX_WITH_MAIN_USB_ID_DATABASE
 VBoxSVC_SOURCES += $(VBoxSVC_0_OUTDIR)/USBIdDatabase.cpp
 VBoxSVC_CLEAN   += $(VBoxSVC_0_OUTDIR)/USBIdDatabase.cpp

 $(call KB_FN_AUTO_CMD_DEPS,$(VBoxSVC_0_OUTDIR)/USBIdDatabase.cpp)
 $(VBoxSVC_0_OUTDIR)/USBIdDatabase.cpp:  $$(USBIdDatabaseGenerator_1_TARGET) \
 		$(PATH_SUB_CURRENT)/src-server/usb.ids $(PATH_SUB_CURRENT)/src-server/custom.ids | $$(dir $$@)
	$(call KB_FN_AUTO_CMD_DEPS_COMMANDS)
	$(call MSG_GENERATE,USBIdDatabase,$@,$(USBIdDatabaseGenerator_1_TARGET))
	$(QUIET)$(USBIdDatabaseGenerator_1_TARGET) -o "$@" $(filter %.ids,$^)

 BLDPROGS += USBIdDatabaseGenerator
 USBIdDatabaseGenerator_TEMPLATE = VBoxAdvBldProg
 USBIdDatabaseGenerator_SOURCES  = src-server/USBIdDatabaseGenerator.cpp
else
 VBoxSVC_SOURCES += src-server/USBIdDatabaseStub.cpp
endif

src-server/win/VBoxSVC.rc_INCS  = $(VBoxSVC_0_OUTDIR)
src-server/win/VBoxSVC.rc_DEPS  = $(VBoxSVC_0_OUTDIR)/VBoxSVC-icon.rc
src-server/win/VBoxSVC.rc_CLEAN = $(VBoxSVC_0_OUTDIR)/VBoxSVC-icon.rc
$(call KB_FN_AUTO_CMD_DEPS,$(VBoxSVC_0_OUTDIR)/VBoxSVC-icon.rc)
$(VBoxSVC_0_OUTDIR)/VBoxSVC-icon.rc: $(VBOX_WINDOWS_ICON_FILE) | $$(dir $$@)
	$(call KB_FN_AUTO_CMD_DEPS_COMMANDS)
	$(APPEND) -t $@ '1 ICON DISCARDABLE "$(subst /,\\,$(VBOX_WINDOWS_ICON_FILE))"'

ifndef VBOX_WITH_MIDL_PROXY_STUB
 src-server/win/VBoxSVC.rc_DEPS  += $(VBoxSVC_0_OUTDIR)/VBoxSVC.rgs
 src-server/win/VBoxSVC.rc_CLEAN += $(VBoxSVC_0_OUTDIR)/VBoxSVC.rgs
 $(call KB_FN_AUTO_CMD_DEPS,$(VBoxSVC_0_OUTDIR)/VBoxSVC.rgs)
 $(VBoxSVC_0_OUTDIR)/VBoxSVC.rgs: $(VBOX_PATH_MAIN_SRC)/src-all/win/VirtualBox_rgs.xsl $(VBOX_XIDL_FILE) | $$(dir $$@)
	$(call KB_FN_AUTO_CMD_DEPS_COMMANDS)
	$(VBOX_XSLTPROC) \
		--stringparam Application VirtualBox \
		--stringparam Module VBoxSVC \
		-o $@ \
		$(VBOX_PATH_MAIN_SRC)/src-all/win/VirtualBox_rgs.xsl \
		$(VBOX_XIDL_FILE)
endif

## @todo r=klaus unfortunately we don't have xmllint everywhere, would be
# good to check the validity for every VirtualBox.xidl change.
#$(VBOX_XIDL_FILE).validated.ts: $(VBOX_XIDL_FILE_SRC)
#	xmllint --dtdvalid $(VBOX_PATH_MAIN_SRC)/idl/VirtualBox.dtd --noout $<
#	$(QUIET)$(CP) --changed -fv $< $(VBOX_XIDL_FILE).validated.ts
#
#OTHERS += $(VBOX_XIDL_FILE).validated.ts
#OTHER_CLEAN += $(VBOX_XIDL_FILE).validated.ts

testvalidxidl: $(VBOX_XIDL_FILE_SRC)
	xmllint --dtdvalid $(VBOX_PATH_MAIN_SRC)/idl/VirtualBox.dtd --noout $<


#
# Embed some constraints from XML Schema file into VBoxSVC
#
VBOX_XML_SCHEMA	= $(VBOX_PATH_MAIN_SRC)/xml/VirtualBox-settings.xsd

$(VBOX_XML_SCHEMADEFS_H): $(VBOX_XML_SCHEMADEFS_XSL) $(VBOX_XML_SCHEMA) | $$(dir $$@)
	$(call MSG_GENERATE,SchemaDefs,$@,$<)
	$(QUIET)$(VBOX_XSLTPROC)  --stringparam mode declare -o $@ $(VBOX_XML_SCHEMADEFS_XSL) $(VBOX_XML_SCHEMA)

$(VBOX_XML_SCHEMADEFS_CPP): $(VBOX_XML_SCHEMADEFS_XSL) $(VBOX_XML_SCHEMA) | $$(dir $$@)
	$(call MSG_GENERATE,SchemaDefs,$@,$<)
	$(QUIET)$(VBOX_XSLTPROC)  --stringparam mode define  -o $@ $(VBOX_XML_SCHEMADEFS_XSL) $(VBOX_XML_SCHEMA)

testvalidsettings: $(VBOX_XML_SCHEMA)
	xmllint --schema $< --noout $(HOME)/.VirtualBox/VirtualBox.xml
	xmllint --schema $< --noout $(HOME)/.VirtualBox/Machines/*/*.xml
	xmllint --schema $< --noout $(HOME)/.VirtualBox/Machines/*/*.vbox
	xmllint --schema $< --noout $(HOME)/VirtualBox\ VMs/*/*.vbox

OTHER_CLEAN += $(VBOX_XML_SCHEMADEFS_H) $(VBOX_XML_SCHEMADEFS_CPP)


#
# Generate some event stuff for VBoxSVC and VBoxC.
#
$(VBOX_AUTOGEN_EVENT_H): $(VBOX_PATH_MAIN_SRC)/idl/comimpl.xsl $(VBOX_XIDL_FILE) | $$(dir $$@)
	$(call MSG_TOOL,xsltproc,autogen events,$<,$@)
	$(QUIET)$(VBOX_XSLTPROC) --stringparam G_kind VBoxEventHeader -o $@ $< $(VBOX_XIDL_FILE)

$(VBOX_AUTOGEN_EVENT_CPP): $(VBOX_PATH_MAIN_SRC)/idl/comimpl.xsl $(VBOX_XIDL_FILE) | $$(dir $$@)
	$(call MSG_TOOL,xsltproc,autogen events,$<,$@)
	$(QUIET)$(VBOX_XSLTPROC) --stringparam G_kind VBoxEvent -o $@ $< $(VBOX_XIDL_FILE)

OTHER_CLEAN += $(VBOX_AUTOGEN_EVENT_H) $(VBOX_AUTOGEN_EVENT_CPP)

ifdef VBOX_WITH_XPCOM
#
# VBoxSVCM - VBoxSVC wrapper module
#
DLLS += VBoxSVCM
VBoxSVCM_TEMPLATE       = VBOXMAINCOMP
VBoxSVCM_DEFS           = IN_RING3 $(VBOX_MAIN_DEFS)
 ifdef VBOX_WITH_HARDENING
VBoxSVCM_DEFS         += VBOX_WITH_HARDENING
 endif
VBoxSVCM_INCS           = \
	include \
	$(VBoxC_0_OUTDIR) \
	.
VBoxSVCM_INTERMEDIATES  = $(VBOX_MAIN_PREREQS)
VBoxSVCM_SOURCES        = \
	src-server/xpcom/server_module.cpp
VBoxSVCM_LDFLAGS.darwin = \
	-install_name $(VBOX_DYLD_EXECUTABLE_PATH)/components/VBoxSVCM.dylib \
	-exported_symbols_list $(VBoxSVCM_0_OUTDIR)/VBoxSVCM.def
 ifeq ($(KBUILD_TARGET),darwin)
VBoxSVCM_ORDERDEPS     += $(VBoxSVCM_0_OUTDIR)/VBoxSVCM.def
VBoxSVCM_CLEAN         += $(VBoxSVCM_0_OUTDIR)/VBoxSVCM.def
$$(VBoxSVCM_0_OUTDIR)/VBoxSVCM.def:
	$(RM) -f $@
	$(APPEND) $@ _NSGetModule
 endif
VBoxSVCM_INTERMEDIATES += $(VBOX_IDL_HEADER.XPCOM)

 # 32-bit version of the module.
 ifdef VBOX_WITH_32_ON_64_MAIN_API
DLLS += VBoxSVCM-x86
VBoxSVCM-x86_TEMPLATE = VBoxMainComp-x86
VBoxSVCM-x86_EXTENDS  = VBoxSVCM
 endif

endif # VBOX_WITH_XPCOM


#
# VBoxC module
#
DLLS += VBoxC
VBoxC_TEMPLATE  = VBOXMAINCOMP
if defined(VBOX_WITH_PRECOMPILED_HEADERS) && "$(KBUILD_TARGET)" == "win"
 VBoxC_USES     = vccprecomp
 VBoxC_PCH_HDR := $(PATH_SUB_CURRENT)/src-client/win/precomp_vcc.h
endif
VBoxC_DEFS = \
	IN_RING3 \
	$(VBOX_MAIN_DEFS) \
	VBOX_COM_INPROC \
	$(if $(VBOX_WITH_HGCM),VBOX_WITH_HGCM,) \
	$(if $(VBOX_WITH_AUDIO_OSS),VBOX_WITH_AUDIO_OSS,) \
	$(if $(VBOX_WITH_AUDIO_ALSA),VBOX_WITH_AUDIO_ALSA,) \
	$(if $(VBOX_WITH_AUDIO_PULSE),VBOX_WITH_AUDIO_PULSE,) \
	$(if $(VBOX_WITH_AUDIO_DEBUG),VBOX_WITH_AUDIO_DEBUG,) \
	$(if $(VBOX_WITH_AUDIO_VALIDATIONKIT),VBOX_WITH_AUDIO_VALIDATIONKIT,) \
	$(if $(VBOX_WITH_AUDIO_VIDEOREC),VBOX_WITH_AUDIO_VIDEOREC,) \
	$(if $(VBOX_WITH_VIDEOREC),VBOX_WITH_VIDEOREC,) \
	$(if $(VBOX_WITH_AUDIO_VRDE),VBOX_WITH_AUDIO_VRDE,) \
	$(if $(VBOX_WITH_E1000),VBOX_WITH_E1000,) \
	$(if $(VBOX_WITH_VIRTIO),VBOX_WITH_VIRTIO,) \
	$(if $(VBOX_WITH_EFI),VBOX_WITH_EFI,) \
	$(if $(VBOX_WITH_PDM_ASYNC_COMPLETION),VBOX_WITH_PDM_ASYNC_COMPLETION,) \
	$(if $(VBOX_WITH_LIVE_MIGRATION),VBOX_WITH_LIVE_MIGRATION,) \
	$(if $(VBOX_WITH_VUSB),VBOX_WITH_VUSB,) \
	$(if $(VBOX_WITH_HGSMI),VBOX_WITH_HGSMI,) \
	$(if $(VBOX_WITH_VIDEOHWACCEL),VBOX_WITH_VIDEOHWACCEL,) \
	$(if $(VBOX_WITH_DRAG_AND_DROP),VBOX_WITH_DRAG_AND_DROP,) \
	$(if $(VBOX_WITH_DRAG_AND_DROP_GH),VBOX_WITH_DRAG_AND_DROP_GH,) \
	$(if $(VBOX_WITH_USB),VBOX_WITH_USB,) \
	$(if-expr defined(VBOX_WITH_EHCI) && defined(VBOX_WITH_USB),VBOX_WITH_EHCI,) \
	$(if $(VBOX_WITH_EXTPACK),VBOX_WITH_EXTPACK,) \
	$(if $(VBOX_WITH_PCI_PASSTHROUGH),VBOX_WITH_PCI_PASSTHROUGH,) \
	$(if $(VBOX_WITH_VRDEAUTH_IN_VBOXSVC),VBOX_WITH_VRDEAUTH_IN_VBOXSVC,) \
	$(if $(VBOX_WITH_SDS),VBOX_WITH_SDS,)
ifdef VBOX_WITH_CRHGSMI
 VBoxC_DEFS += VBOX_WITH_CRHGSMI
endif
ifdef VBOX_WITH_NETSHAPER
 VBoxC_DEFS += VBOX_WITH_NETSHAPER
endif
VBoxC_DEFS.darwin.x86 = VBOX_WITH_2X_4GB_ADDR_SPACE
VBoxC_DEFS.win.x86 += _WIN32_WINNT=0x0500
VBoxC_DEFS.win.amd64 += _WIN32_WINNT=0x0510

if $(KBUILD_TARGET) != "win" && $(VBOX_GCC_VERSION_CXX) >= 40900 # gcc 4.9.x (4.8.x is causing endless RT_ELEMENT trouble)
# VBoxC_CXXFLAGS = -Wunused -Wconversion
endif

VBoxC_SDKS = VBOX_LIBPNG VBOX_ZLIB

ifdef VBOX_WITH_VIDEOREC
   VBoxC_SOURCES += \
	src-client/EBMLWriter.cpp \
	src-client/WebMWriter.cpp
  ifdef VBOX_WITH_LIBVPX
   VBoxC_SDKS += VBOX_VPX
   VBoxC_DEFS += VBOX_WITH_LIBVPX
   VBoxC_SOURCES += \
	src-client/VideoRec.cpp
  else
   $(error "VBox: No alternative for VPX when using video capturing support yet")
  endif
endif

ifdef VBOX_WITH_AUDIO_VIDEOREC
  ifdef VBOX_WITH_LIBOPUS
   VBoxC_SDKS += VBOX_OPUS
   VBoxC_DEFS += VBOX_WITH_LIBOPUS
  else
   $(error "VBox: No alternative for Opus when using audio support for video capturing yet")
  endif
endif

ifdef VBOX_WITH_OPENSSL_FIPS
  VBoxC_SDKS += VBOX_OPENSSL2
endif

VBoxC_INCS          = \
	include \
	$(VBoxC_0_OUTDIR) \
	$(VBOX_MAIN_APIWRAPPER_INCS) \
	$(dir $(VBOX_XML_SCHEMADEFS_H)) \
	$(VBOX_MAIN_APIWRAPPER_DIR)/dtrace \
	$(VBOX_GRAPHICS_INCS)
VBoxC_INCS.win      = \
	$(VBoxCOM_0_OUTDIR) \
	.

VBoxC_LDFLAGS.darwin = \
	-install_name $(VBOX_DYLD_EXECUTABLE_PATH)/components/VBoxC.dylib \
	-exported_symbols_list $(VBoxC_0_OUTDIR)/VBoxC.def \
	-framework IOKit
VBoxC_LDFLAGS.win += /MANIFEST \
  	/DELAYLOAD:user32.dll


VBoxC_LIBS += \
	$(PATH_STAGE_LIB)/VBoxAPIWrap$(VBOX_SUFF_LIB) \
	$(if-expr "$(LIB_VMM)" == "$(VBOX_LIB_VMM_LAZY)",$(LIB_REM),) \
	$(VBOX_LIB_VMM_LAZY)
VBoxC_LIBS.win += \
	$(PATH_SDK_$(VBOX_WINPSDK)_LIB)/psapi.lib \
	$(PATH_TOOL_$(VBOX_VCC_TOOL)_LIB)/delayimp.lib
ifdef VBOX_WITH_NETFLT
 VBoxC_LIBS.win += \
	$(PATH_STAGE_LIB)/VBoxDrvCfg$(VBOX_SUFF_LIB) \
	$(PATH_SDK_$(VBOX_WINDDK)_LIB)/newdev.lib \
	$(PATH_STAGE_LIB)/WinNetConfig$(VBOX_SUFF_LIB) \
	$(PATH_TOOL_$(VBOX_VCC_TOOL)_LIB)/comsupp.lib \
	$(PATH_SDK_$(VBOX_WINPSDK)_LIB)/WbemUuid.Lib
 VBoxC_LDFLAGS.win += \
  	/DELAYLOAD:newdev.dll \
  	/DELAYLOAD:setupapi.dll \
  	/DELAYLOAD:iphlpapi.dll
endif

ifdef VBOX_WITH_CROGL
 VBoxC_LIBS += $(PATH_STAGE_LIB)/VBoxOGLTest$(VBOX_SUFF_LIB)
 VBoxC_LDFLAGS.darwin += -framework OpenGL
endif

ifdef VBOX_WITH_DRAG_AND_DROP
 VBoxC_LIBS += $(PATH_STAGE_LIB)/VBoxDnDHostR3Lib$(VBOX_SUFF_LIB)
endif

VBoxC_INTERMEDIATES = \
	$(VBOX_MAIN_PREREQS) \
	$(VBOX_XML_SCHEMADEFS_H) \
	$(VBOX_AUTOGEN_EVENT_H) \
	$(VBOX_MAIN_APIWRAPPER_GEN_HDRS)

VBoxC_SOURCES += \
	$(VBoxAPIWrap_0_OUTDIR)/VBoxAPI.d \
	src-all/DisplayPNGUtil.cpp \
	src-all/DisplayResampleImage.cpp \
	src-all/DisplayUtils.cpp \
	src-all/EventImpl.cpp \
	src-all/Global.cpp \
	src-all/HashedPw.cpp \
	src-all/Logging.cpp \
	src-all/PCIDeviceAttachmentImpl.cpp \
	src-all/ProgressImpl.cpp \
	src-all/SecretKeyStore.cpp \
	src-all/SharedFolderImpl.cpp \
	src-all/AutoCaller.cpp \
	src-all/ThreadTask.cpp \
	src-all/VirtualBoxBase.cpp \
	src-all/VirtualBoxErrorInfoImpl.cpp \
	$(if $(VBOX_WITH_EXTPACK),src-all/ExtPackManagerImpl.cpp src-all/ExtPackUtil.cpp,) \
	src-client/UsbWebcamInterface.cpp \
	$(if $(VBOX_WITH_USB_CARDREADER),src-client/UsbCardReader.cpp,) \
	src-client/Nvram.cpp \
	src-client/AdditionsFacilityImpl.cpp \
	src-client/BusAssignmentManager.cpp \
	$(if $(VBOX_WITH_PCI_PASSTHROUGH),src-client/PCIRawDevImpl.cpp,) \
	src-client/ClientTokenHolder.cpp \
	src-client/ConsoleImpl.cpp \
	src-client/ConsoleImpl2.cpp \
	src-client/ConsoleImplTeleporter.cpp \
	src-client/ConsoleVRDPServer.cpp \
	src-client/DisplayImpl.cpp \
	src-client/DisplayImplLegacy.cpp \
	src-client/DisplaySourceBitmapImpl.cpp \
	src-client/EmulatedUSBImpl.cpp \
	src-client/GuestImpl.cpp \
	src-client/GuestCtrlImpl.cpp \
	src-client/KeyboardImpl.cpp \
	src-client/MachineDebuggerImpl.cpp \
	src-client/MouseImpl.cpp \
	src-client/RemoteUSBDeviceImpl.cpp \
	src-client/SessionImpl.cpp \
	src-client/USBDeviceImpl.cpp \
	src-client/VBoxDriversRegister.cpp \
	src-client/VirtualBoxClientImpl.cpp \
	src-client/VMMDevInterface.cpp \
	$(VBOX_AUTOGEN_EVENT_CPP) \
	$(VBOX_XML_SCHEMADEFS_CPP)

# Audio bits.
VBoxC_SOURCES += \
	../Devices/Audio/AudioMixBuffer.cpp \
	../Devices/Audio/DrvAudioCommon.cpp \
	src-client/AudioDriver.cpp \
	$(if $(VBOX_WITH_AUDIO_VRDE),src-client/DrvAudioVRDE.cpp,) \
	$(if $(VBOX_WITH_AUDIO_VIDEOREC),src-client/DrvAudioVideoRec.cpp,)

VBoxC_SOURCES.win = \
	src-client/win/dllmain.cpp \
	src-client/win/VBoxC.def \
	src-client/win/VBoxC.rc
ifdef VBOX_WITH_GUEST_CONTROL
 VBoxC_SOURCES += \
	src-client/GuestSessionImplTasks.cpp \
	src-client/GuestCtrlPrivate.cpp \
	src-client/GuestDirectoryImpl.cpp \
	src-client/GuestFileImpl.cpp \
	src-client/GuestFsObjInfoImpl.cpp \
	src-client/GuestProcessImpl.cpp \
	src-client/GuestSessionImpl.cpp
endif
ifdef VBOX_WITH_DRAG_AND_DROP
 VBoxC_SOURCES += \
	src-client/GuestDnDPrivate.cpp \
	src-client/GuestDnDSourceImpl.cpp \
	src-client/GuestDnDTargetImpl.cpp
endif
ifdef VBOX_WITH_XPCOM
 VBoxC_SOURCES += \
	src-client/xpcom/module.cpp
endif
ifdef VBOX_WITH_HGCM
 VBoxC_SOURCES += \
	src-client/HGCMObjects.cpp \
	src-client/HGCMThread.cpp \
	src-client/HGCM.cpp
endif
ifdef VBOX_WITH_USB
 VBoxC_SOURCES += \
	src-client/RemoteUSBBackend.cpp
endif
ifndef VBOX_WITH_VRDEAUTH_IN_VBOXSVC
 VBoxC_SOURCES += \
	src-all/AuthLibrary.cpp
endif

$(call KB_FN_DO_PASS0_ON_TARGET,VBoxC) # Sets VBoxC_0_OUTDIR

ifeq ($(KBUILD_TARGET),darwin)
 VBoxC_ORDERDEPS += $(VBoxC_0_OUTDIR)/VBoxC.def
 VBoxC_CLEAN     += $(VBoxC_0_OUTDIR)/VBoxC.def
 $(call KB_FN_AUTO_CMD_DEPS,$(VBoxC_0_OUTDIR)/VBoxC.def)
 $(VBoxC_0_OUTDIR)/VBoxC.def:
	$(call KB_FN_AUTO_CMD_DEPS_COMMANDS)
	$(RM) -f $@
	$(APPEND) $@ _NSGetModule
	$(APPEND) $@ _VBoxDriversRegister
endif

src-client/ConsoleImpl.cpp_DEFS = \
	$(if $(VBOX_WITH_OPENSSL_FIPS), VBOX_OPENSSL_FIPS,)


src-client/win/VBoxC.rc_DEPS = $(VBoxC_0_OUTDIR)/VBoxC.rgs $(VBoxCOM_0_OUTDIR)/VirtualBox.tlb
VBoxC_CLEAN.win             += $(VBoxC_0_OUTDIR)/VBoxC.rgs
$(call KB_FN_AUTO_CMD_DEPS,$(VBoxC_0_OUTDIR)/VBoxC.rgs)
$(VBoxC_0_OUTDIR)/VBoxC.rgs: $(VBOX_PATH_MAIN_SRC)/src-all/win/VirtualBox_rgs.xsl $(VBOX_XIDL_FILE) | $$(dir $$@)
	$(call KB_FN_AUTO_CMD_DEPS_COMMANDS)
	$(VBOX_XSLTPROC) \
		--stringparam Application VirtualBox \
		--stringparam Module VBoxC \
		-o $@ \
		$(VBOX_PATH_MAIN_SRC)/src-all/win/VirtualBox_rgs.xsl \
		$(VBOX_XIDL_FILE)

ifdef VBOX_WITH_32_ON_64_MAIN_API
 #
 # 32-bit VBox API Client In-Process module.
 #
 # This is currently just a 32-bit version of VBoxC.  It might be desirable to
 # split up VBoxC into a simple client and a VM client part later, in which
 # case this module will be a simple client.
 #
 # Note! One important thing is that the typelib for this DLL must be build
 #       with the /env win32 switch and the VBoxC typelib with /env amd64, if
 #       not they will overwrite each others typelib module entry.
 #
 DLLS += VBoxClient-x86
 VBoxClient-x86_TEMPLATE = VBoxMainComp-x86
 VBoxClient-x86_EXTENDS  = VBoxC
if defined(VBOX_WITH_PRECOMPILED_HEADERS) && "$(KBUILD_TARGET)" == "win" ## @todo fix inheritance
 VBoxClient-x86_USES     = vccprecomp
 VBoxClient-x86_PCH_HDR := $(PATH_SUB_CURRENT)/src-client/win/precomp_vcc.h
endif
 VBoxClient-x86_DEFS = VBOX_COM_INPROC_API_CLIENT $(VBoxC_DEFS)
 VBoxClient-x86_INCS.win = \
 	$(VBoxClient-x86_0_OUTDIR) \
 	$(VBoxCOM-x86_0_OUTDIR) \
	$(VBoxC_INCS.win)
 VBoxClient-x86_SOURCES = \
 	src-all/EventImpl.cpp \
 	src-all/Global.cpp \
	src-all/AutoCaller.cpp \
 	src-all/ThreadTask.cpp \
 	src-all/VirtualBoxBase.cpp \
 	src-all/VirtualBoxErrorInfoImpl.cpp \
 	src-client/ClientTokenHolder.cpp \
 	src-client/SessionImpl.cpp \
 	src-client/VirtualBoxClientImpl.cpp \
 	$(VBOX_AUTOGEN_EVENT_CPP) \
 	$(VBOX_XML_SCHEMADEFS_CPP)
 VBoxClient-x86_SOURCES.win = \
 	src-client/win/dllmain.cpp \
 	src-client/win/VBoxClient-x86.def \
 	src-client/win/VBoxClient-x86.rc
 ifdef VBOX_WITH_XPCOM
  VBoxClient-x86_SOURCES += \
  	src-client/xpcom/module.cpp
 endif
 VBoxClient-x86_LIBS = \
	$(PATH_STAGE_LIB)/VBoxAPIWrap-x86$(VBOX_SUFF_LIB)
 VBoxClient-x86_LIBS.win = $(NO_SUCH_VARIABLE)
 VBoxClient-x86_LIBS.win.x86 += \
    $(PATH_TOOL_$(VBOX_VCC_TOOL_STEM)X86_LIB)/delayimp.lib \
	$(PATH_SDK_$(VBOX_WINPSDK)_LIB.x86)/WbemUuid.Lib
 VBoxClient-x86_CLEAN.win += $(VBoxClient-x86_0_OUTDIR)/VBoxClient-x86.rgs
 $(call KB_FN_DO_PASS0_ON_TARGET,VBoxClient-x86) # Sets VBoxClient-x86_0_OUTDIR

 src-client/win/VBoxClient-x86.rc_DEPS = \
 	$(VBoxClient-x86_0_OUTDIR)/VBoxClient-x86.rgs \
 	$(VBoxCOM-x86_0_OUTDIR)/VirtualBox-x86.tlb

 $(call KB_FN_AUTO_CMD_DEPS,$(VBoxClient-x86_0_OUTDIR)/VBoxClient-x86.rgs)
 $(VBoxClient-x86_0_OUTDIR)/VBoxClient-x86.rgs: \
 		$(VBOX_PATH_MAIN_SRC)/src-all/win/VirtualBox_rgs.xsl \
		$(VBOX_XIDL_FILE) | $$(dir $$@)
	$(call KB_FN_AUTO_CMD_DEPS_COMMANDS)
	$(VBOX_XSLTPROC) \
		--stringparam Application VirtualBox \
		--stringparam Module VBoxC \
		-o $@ \
		$(VBOX_PATH_MAIN_SRC)/src-all/win/VirtualBox_rgs.xsl \
		$(VBOX_XIDL_FILE)
endif

#
# The VBoxExtPackHelperApp.
#
ifdef VBOX_WITH_EXTPACK
 PROGRAMS += VBoxExtPackHelperApp
 VBoxExtPackHelperApp_TEMPLATE = VBoxR3SetUidToRoot
 VBoxExtPackHelperApp_LDFLAGS.darwin = -framework Security
 VBoxExtPackHelperApp_LDFLAGS.win = /SUBSYSTEM:windows
 VBoxExtPackHelperApp_SOURCES = \
	src-helper-apps/VBoxExtPackHelperApp.cpp \
	src-all/ExtPackUtil.cpp
 VBoxExtPackHelperApp_SOURCES.win = \
	src-helper-apps/VBoxExtPackHelperApp.rc
 VBoxExtPackHelperApp_LIBS = \
	$(LIB_RUNTIME)
endif # VBOX_WITH_EXTPACK

#
# VolInfo
#
ifdef VBOX_WITH_DEVMAPPER
 PROGRAMS.linux      += VBoxVolInfo
 VBoxVolInfo_TEMPLATE = VBoxR3SetUidToRoot
 VBoxVolInfo_SOURCES  = src-helper-apps/VBoxVolInfo.cpp
 VBoxVolInfo_LIBS     = devmapper
endif


endif # !defined(VBOX_ONLY_SDK) && !defined(VBOX_ONLY_EXTPACKS) (the ifndef is far above)
ifndef VBOX_ONLY_SDK


#
# VBoxCOM - COM Abstraction Layer library
#
LIBRARIES += VBoxCOM
VBoxCOM_TEMPLATE        = VBoxMainLib
VBoxCOM_INTERMEDIATES   = $(VBOX_MAIN_PREREQS) \
                          $(VBOX_MAIN_APIWRAPPER_GEN_HDRS)
VBoxCOM_SOURCES         = \
	glue/com.cpp \
	glue/VBoxLogRelCreate.cpp \
	glue/GetVBoxUserHomeDirectory.cpp \
	glue/initterm.cpp \
	glue/string.cpp \
	glue/AutoLock.cpp \
	glue/EventQueue.cpp \
	glue/NativeEventQueue.cpp \
	glue/ErrorInfo.cpp \
	glue/errorprint.cpp
VBoxCOM_INCS          += $(VBOX_MAIN_APIWRAPPER_INCS) \
	include
ifeq ($(KBUILD_TARGET),win)
 ifdef VBOX_WITH_MIDL_PROXY_STUB
  VBoxCOM_DEFS.win      = VBOX_WITH_AUTO_COM_REG_UPDATE
 endif
 VBoxCOM_DEFS.x86       = _WIN32_WINNT=0x0500
 VBoxCOM_DEFS.amd64     = _WIN32_WINNT=0x0510
 VBoxCOM_SOURCES       += \
	$(VBoxCOM_0_OUTDIR)/VirtualBox_i.c
 VBoxCOM_CLEAN          = \
 	$(VBoxCOM_0_OUTDIR)/VirtualBox_i.c \
 	$(VBoxCOM_0_OUTDIR)/VirtualBox_p.c \
 	$(VBoxCOM_0_OUTDIR)/dlldata.c \
 	$(VBoxCOM_0_OUTDIR)/VirtualBox.h \
 	$(VBoxCOM_0_OUTDIR)/VirtualBox.tlb
 VBoxCOM_CLEAN        += \
	$(VBoxCOM_0_OUTDIR)/legacy/VirtualBox_i.c \
	$(VBoxCOM_0_OUTDIR)/legacy/VirtualBox_p.c \
	$(VBoxCOM_0_OUTDIR)/legacy/dlldata.c \
	$(VBoxCOM_0_OUTDIR)/legacy/VirtualBox.h \
	$(VBoxCOM_0_OUTDIR)/legacy/VirtualBox.tlb
 VBoxCOM_BLDDIRS      = $(VBoxCOM_0_OUTDIR)/legacy/
else # !win
 VBoxCOM_SOURCES       += \
	$(VBoxCOM_0_OUTDIR)/VirtualBox_XPCOM_i.c \
	glue/xpcom/helpers.cpp
endif # !win

glue/VBoxLogRelCreate.cpp_DEFS = KBUILD_TYPE=\"$(KBUILD_TYPE)\"

# 32-bit version of VBoxCOM.
if defined(VBOX_WITH_32_ON_64_MAIN_API) && !defined(VBOX_ONLY_EXTPACKS)
 LIBRARIES += VBoxCOM-x86
 VBoxCOM-x86_TEMPLATE = VBoxMainLib-x86
 VBoxCOM-x86_EXTENDS  = VBoxCOM
 ifeq ($(KBUILD_TARGET),win)
  VBoxCOM-x86_CLEAN   = \
 	$(VBoxCOM-x86_0_OUTDIR)/VirtualBox_i.c \
 	$(VBoxCOM-x86_0_OUTDIR)/VirtualBox_p.c \
 	$(VBoxCOM-x86_0_OUTDIR)/dlldata.c \
 	$(VBoxCOM-x86_0_OUTDIR)/VirtualBox.h \
 	$(VBoxCOM-x86_0_OUTDIR)/VirtualBox.tlb
 endif
endif

# -MD version for the GUI in -MDd builds.
ifeq ($(KBUILD_TARGET).$(VBOX_VCC_CRT_TYPE),win.d)
 ifndef VBOX_ONLY_EXTPACKS
  LIBRARIES += VBoxCOM-GUI
  USES += qt5
  VBoxCOM-GUI_TEMPLATE = VBOXQTGUI$(if-expr defined(VBOX_WITH_HARDENING),,EXE)
  VBoxCOM-GUI_EXTENDS  = VBoxCOM
 endif
endif

endif # !VBOX_ONLY_SDK


#
# Installs com related thing(s) to bin.
#
INSTALLS.win += VBoxMain-com-inst
VBoxMain-com-inst_INST = $(INST_BIN)
VBoxMain-com-inst_MODE = a+r,u+w
VBoxMain-com-inst_SOURCES = src-all/win/comregister.cmd


if defined(VBOX_WITH_HARDENING) && "$(KBUILD_TARGET)" == "linux" && !defined(VBOX_ONLY_EXTPACKS)
 #
 # Installs linux/hardening related things to components.
 #
 INSTALLS.linux += VBoxMain-hardening-inst
 VBoxMain-hardening-inst_INST = $(INST_BIN)components/
 VBoxMain-hardening-inst_SYMLINKS = \
	VBoxDDU.so=>../VBoxDDU.so \
	VBoxREM.so=>../VBoxREM.so \
	VBoxRT.so=>../VBoxRT.so \
	VBoxVMM.so=>../VBoxVMM.so \
	VBoxXPCOM.so=>../VBoxXPCOM.so
endif


if defined(VBOX_WITH_MIDL_PROXY_STUB) && "$(KBUILD_TARGET)" == "win" && !defined(VBOX_ONLY_EXTPACKS)
 #
 # Experimental COM proxy + stub DLL w/ automatic registration updating.
 #
 # The Legacy stub is for older 64-bit windows versions (pre Windows 7) as we
 # were having various problems on windows server 2003 and 2008 with the code
 # MIDL generated.  Also, in windows 7 there are some potentially interesting
 # changes in the generated code where it uses new helpers from OLE32.
 #
 DLLS += VBoxProxyStub
 VBoxProxyStub_TEMPLATE = VBOXMAINCOMP
 VBoxProxyStub_DEFS     = REGISTER_PROXY_DLL PROXY_CLSID_IS="$(VBOX_MIDL_PROXY_CLSID_IS)" \
	$(if $(VBOX_WITH_SDS),VBOX_WITH_SDS,)\
 	$(if $(VBOX_WITH_SDS_CLIENT_WATCHER),VBOX_WITH_SDS_CLIENT_WATCHER,)
 VBoxProxyStub_DEFS.win.x86 = WIN32
 VBoxProxyStub_SDKS     = VBOX_NTDLL
 VBoxProxyStub_DEFPATH  = $(VBoxCOM_0_OUTDIR)/# Hack to workaround drive letter in $(VBoxCOM_0_OUTDIR)/ for CFLAGS hack below.
 VBoxProxyStub_INCS     = $(VBoxCOM_0_OUTDIR)/ \
    $(VBOX_PATH_MAIN_SRC)/include/
 VBoxProxyStub_SOURCES := \
 	VirtualBox_p.c \
 	VirtualBox_i.c \
 	$(PATH_SUB_CURRENT)/src-all/win/VBoxProxyStub.def \
 	$(PATH_SUB_CURRENT)/src-all/win/VBoxProxyStub.rc \
 	$(PATH_SUB_CURRENT)/src-all/win/RpcChannelHook.cpp \
 	$(PATH_SUB_CURRENT)/src-all/win/VBoxProxyStub.c
 src-all/win/VBoxProxyStub.rc_DEPS = $(VBoxCOM_0_OUTDIR)/VirtualBox.tlb
 VBoxProxyStub_VirtualBox_p.c_CFLAGS.x86 = /Gz # Workaround for incorrect ObjectStublessClient* prototypes in SDK v7.1.

 DLLS += VBoxProxyStubLegacy
 VBoxProxyStubLegacy_TEMPLATE = VBOXMAINCOMP
 VBoxProxyStubLegacy_EXTENDS  = VBoxProxyStub
 VBoxProxyStubLegacy_DEFS     = $(VBoxProxyStub_DEFS) VBOX_IN_PROXY_STUB_LEGACY
 VBoxProxyStubLegacy_INCS     = $(VBoxCOM_0_OUTDIR)/legacy/ \
    $(VBOX_PATH_MAIN_SRC)/include/
 VBoxProxyStubLegacy_SOURCES  = \
 	$(VBoxCOM_0_OUTDIR)/legacy/VirtualBox_p.c \
 	$(VBoxCOM_0_OUTDIR)/legacy/VirtualBox_i.c \
 	src-all/win/VBoxProxyStub.def \
 	src-all/win/VBoxProxyStubLegacy.rc \
 	src-all/win/RpcChannelHook.cpp \
  	src-all/win/VBoxProxyStub.c
 src-all/win/VBoxProxyStubLegacy.rc_DEPS = $(VBoxCOM_0_OUTDIR)/legacy/VirtualBox.tlb

 ifdef VBOX_WITH_32_ON_64_MAIN_API
  DLLS += VBoxProxyStub-x86
  VBoxProxyStub-x86_TEMPLATE = VBoxMainComp-x86
  VBoxProxyStub-x86_SDKS     = VBOX_NTDLL
  VBoxProxyStub-x86_DEFS     = $(VBoxProxyStub_DEFS) VBOX_PROXY_STUB_32_ON_64 WIN32
  VBoxProxyStub-x86_INCS     = $(VBoxCOM-x86_0_OUTDIR)/ \
  	$(VBOX_PATH_MAIN_SRC)/include/
  VBoxProxyStub-x86_SOURCES  = \
  	$(VBoxCOM-x86_0_OUTDIR)/VirtualBox_p.c \
  	$(VBoxCOM-x86_0_OUTDIR)/VirtualBox_i.c \
 	src-all/win/VBoxProxyStub.c \
 	src-all/win/VBoxProxyStub-x86.rc \
 	src-all/win/RpcChannelHook.cpp \
 	src-all/win/VBoxProxyStub.def
  src-all/win/VBoxProxyStub-x86.rc_DEPS = $(VBoxCOM-x86_0_OUTDIR)/VirtualBox-x86.tlb
 endif
endif



# generate rules
include $(FILE_KBUILD_SUB_FOOTER)



#
# Additions rules.
#

## @todo this hack ain't cutting it any longer. (the file name is abspath'ed since ages now.)
glue/xpcom/helpers.cpp: $(VBOX_IDL_TYPELIB.XPCOM)

$(call KB_FN_AUTO_CMD_DEPS_EX,$(VBOX_IDL_FILE.XPCOM),$(PATH_OUT)/VBOX_IDL_FILE.XPCOM.vbox-dep)
$(VBOX_IDL_FILE.XPCOM): $(VBOX_PATH_MAIN_SRC)/idl/xpidl.xsl $(VBOX_XIDL_FILE) | $$(dir $$@)
	$(call KB_FN_AUTO_CMD_DEPS_COMMANDS_EX,$(PATH_OUT)/VBOX_IDL_FILE.XPCOM.vbox-dep)
	$(call MSG_TOOL,xsltproc,VBoxSVC,$(VBOX_PATH_MAIN_SRC)/idl/xpidl.xsl,$@)
	$(QUIET)$(VBOX_XSLTPROC) -o $@ $(VBOX_PATH_MAIN_SRC)/idl/xpidl.xsl $(VBOX_XIDL_FILE)

$(call KB_FN_AUTO_CMD_DEPS_EX,$(VBOX_IDL_TYPELIB.XPCOM),$(PATH_OUT)/VBOX_IDL_TYPELIB.XPCOM.vbox-dep)
$(VBOX_IDL_TYPELIB.XPCOM): $(VBOX_IDL_FILE.XPCOM) |  $$(dir $$@) $(VBOX_XPIDL)
	$(call KB_FN_AUTO_CMD_DEPS_COMMANDS_EX,$(PATH_OUT)/VBOX_IDL_TYPELIB.XPCOM.vbox-dep)
	$(call MSG_TOOL,xpidl,VBoxSVC,$(VBOX_IDL_FILE.XPCOM),$@)
	$(QUIET)$(VBOX_XPIDL_ENV)$(VBOX_XPIDL) -m typelib -I $(VBOX_PATH_XPCOM_IDL) -e $@ $(VBOX_IDL_FILE.XPCOM)
	$(CHMOD) 0644 $@
## @todo ^^^^^^^^^^^^ fix horrible hack

$(call KB_FN_AUTO_CMD_DEPS_EX,$(VBOX_IDL_HEADER.XPCOM),$(PATH_OUT)/VBOX_IDL_HEADER.XPCOM.vbox-dep)
$(VBOX_IDL_HEADER.XPCOM): $(VBOX_IDL_FILE.XPCOM) | $$(dir $$@) $(VBOX_XPIDL)
	$(call KB_FN_AUTO_CMD_DEPS_COMMANDS_EX,$(PATH_OUT)/VBOX_IDL_HEADER.XPCOM.vbox-dep)
	$(call MSG_TOOL,xpidl,VBoxSVC,$(VBOX_IDL_FILE.XPCOM),$@)
	$(QUIET)$(VBOX_XPIDL_ENV)$(VBOX_XPIDL) -m header  -I $(VBOX_PATH_XPCOM_IDL) -e $@ $(VBOX_IDL_FILE.XPCOM)

$(call KB_FN_AUTO_CMD_DEPS_EX,$(VBOX_IDL_FILE.MSCOM),$(PATH_OUT)/VBOX_IDL_FILE.MSCOM.vbox-dep)
$(VBOX_IDL_FILE.MSCOM): $(VBOX_PATH_MAIN_SRC)/idl/midl.xsl $(VBOX_XIDL_FILE) | $$(dir $$@)
	$(call KB_FN_AUTO_CMD_DEPS_COMMANDS_EX,$(PATH_OUT)/VBOX_IDL_FILE.MSCOM.vbox-dep)
	$(call MSG_TOOL,xsltproc,VBoxSVC,$<,$@)
	$(QUIET)$(VBOX_XSLTPROC) -o $@ \
		$(if $(VBOX_WITH_MIDL_PROXY_STUB),-stringparam g_fGenProxy yes,) \
		$(if $(VBOX_WITH_SDS),-stringparam g_fVBoxWithSDS yes,) \
		$(VBOX_PATH_MAIN_SRC)/idl/midl.xsl $(VBOX_XIDL_FILE)


# Aliases for testing purposes.
ifdef VBOX_WITH_XPCOM
testidl:    $(VBOX_IDL_FILE.XPCOM) $(VBOX_IDL_TYPELIB.XPCOM) $(VBoxCOM_0_OUTDIR)/VirtualBox_XPCOM_i.c
testidlhdr: $(VBOX_IDL_HEADER.XPCOM)
else
testidl:    $(VBOX_IDL_FILE.MSCOM) $(VBoxCOM_0_OUTDIR)/VirtualBox_i.c \
	$(if $(VBOX_WITH_32_ON_64_MAIN_API),$(VBoxCOM-x86_0_OUTDIR)/VirtualBox_i.c,)
endif


$(VBoxCOM_0_OUTDIR)/VirtualBox_XPCOM_i.c: $(VBOX_PATH_MAIN_SRC)/idl/xpidl_iid.xsl $(VBOX_XIDL_FILE) | $$(dir $$@)
	$(call MSG_TOOL,xsltproc,VBoxSVC,$<,$@)
	$(QUIET)$(VBOX_XSLTPROC) -o $@ $< $(VBOX_XIDL_FILE)

##
# Edits $1 and adding #pragma directives for disabling warnings windows.h causes.
# @param 1     The name of the file to edit.
define def_VBoxMainDisableMscWarnings
	$(QUIET)$(MV) -f "$1" "$1.tmp"
	$(QUIET)$(APPEND) -nt "$1" \
		'#pragma warning(push) /* -Wall and windows.h */' \
		'#pragma warning(disable:4668 4255)' \
		'#if _MSC_VER >= 1800 /* RT_MSC_VER_VC120 */' \
		'# pragma warning(disable:4005)' \
		'#endif' \
               ''
	$(QUIET)$(CAT_EXT) "$1.tmp" >> "$1"
	$(QUIET)$(APPEND) -n "$1" \
		'' \
		'#pragma warning(pop)' \
               ''
	$(QUIET)$(RM) -f "$1.tmp"

endef

# Note! Because we've got a different proxy stub DLL for pre windows 7 64-bit hosts, we target windows 7 for AMD64.
#       The output is different and hopefully more efficient, at least memory wise (using more helpers in OLE32).
# Note! We're checking for win.amd64 below when setting the target because of the SDK build which happens on linux.amd64
#       but with a 32-bit Wine.
$(call KB_FN_AUTO_CMD_DEPS,$(VBoxCOM_0_OUTDIR)/VirtualBox_i.c)
$(VBoxCOM_0_OUTDIR)/VirtualBox_i.c \
$(if $(VBOX_WITH_MIDL_PROXY_STUB), + $(VBoxCOM_0_OUTDIR)/VirtualBox_p.c + $(VBoxCOM_0_OUTDIR)/dlldata.c,) \
+ $(VBoxCOM_0_OUTDIR)/VirtualBox.h \
+ $(VBoxCOM_0_OUTDIR)/VirtualBox.tlb: $(VBOX_IDL_FILE.MSCOM) | $$(dir $$@)
	$(call KB_FN_AUTO_CMD_DEPS_COMMANDS)
	$(VBOX_WIN_MIDL) /nologo /W4 \
		/env $(if-expr "$(KBUILD_TARGET).$(KBUILD_TARGET_ARCH)" == "win.amd64" ,amd64,win32) \
		/robust /protocol all /target $(if-expr defined(VBOX_WITH_MIDL_PROXY_STUB),NT61,NT51) \
		/out $(call VBOX_FN_MAKE_WIN_PATH,$(VBoxCOM_0_OUTDIR)) \
		/cpp_cmd $(subst $(EXEC_X86_WIN32),,$(call VBOX_FN_MAKE_WIN_PATH,$(TOOL_$(VBOX_VCC_TOOL)_CC))) \
		/I $(call VBOX_FN_MAKE_WIN_PATH,$(PATH_SDK_$(VBOX_WINPSDK)_INC)) \
		/I idl \
		$(call VBOX_FN_MAKE_WIN_PATH,$(VBOX_IDL_FILE.MSCOM))
	$(call def_VBoxMainDisableMscWarnings,$(VBoxCOM_0_OUTDIR)/VirtualBox.h)
	$(call def_VBoxMainDisableMscWarnings,$(VBoxCOM_0_OUTDIR)/VirtualBox_i.c)
	$(call def_VBoxMainDisableMscWarnings,$(VBoxCOM_0_OUTDIR)/VirtualBox_p.c)

if defined(VBOX_WITH_MIDL_PROXY_STUB)
# -Windows Server 2003 AMD64 SP1 does not like the result when using '/protocol all' and '/target NT51'.
# -Vista AMD64 SP1 and Windows Server 2008 AMD64 seems to have some objections as well, but it seemed
#  that using an older MIDL compiler (v7.00.0499 instead of v7.00.0555) helps. But the W2K3 fix also works.
# To avoid 32-bit vs. 64-bit differences, we do the same for 32-bit windows versions.
$(call KB_FN_AUTO_CMD_DEPS,$(VBoxCOM_0_OUTDIR)/legacy/VirtualBox_i.c)
$(VBoxCOM_0_OUTDIR)/legacy/VirtualBox_i.c \
+ $(VBoxCOM_0_OUTDIR)/legacy/VirtualBox_p.c\
+ $(VBoxCOM_0_OUTDIR)/legacy/dlldata.c \
+ $(VBoxCOM_0_OUTDIR)/legacy/VirtualBox.h \
+ $(VBoxCOM_0_OUTDIR)/legacy/VirtualBox.tlb: $(VBOX_IDL_FILE.MSCOM) | $$(dir $$@)
	$(call KB_FN_AUTO_CMD_DEPS_COMMANDS)
	$(VBOX_WIN_MIDL) /nologo /W4 \
		$(if-expr "$(KBUILD_TARGET).$(KBUILD_TARGET_ARCH)" == "win.amd64" \
		,/env amd64 /x64 /target NT50 /robust \
		,/env win32      /target NT51 /robust /protocol all ) \
		/out $(call VBOX_FN_MAKE_WIN_PATH,$(dir $@)) \
		/cpp_cmd $(subst $(EXEC_X86_WIN32),,$(call VBOX_FN_MAKE_WIN_PATH,$(TOOL_$(VBOX_VCC_TOOL)_CC))) \
		/I $(call VBOX_FN_MAKE_WIN_PATH,$(PATH_SDK_$(VBOX_WINPSDK)_INC)) \
		/I idl \
		$(call VBOX_FN_MAKE_WIN_PATH,$(VBOX_IDL_FILE.MSCOM))
	$(call def_VBoxMainDisableMscWarnings,$(VBoxCOM_0_OUTDIR)/legacy/VirtualBox.h)
	$(call def_VBoxMainDisableMscWarnings,$(VBoxCOM_0_OUTDIR)/legacy/VirtualBox_i.c)
	$(call def_VBoxMainDisableMscWarnings,$(VBoxCOM_0_OUTDIR)/legacy/VirtualBox_p.c)
endif

# The XP targetted 32-bit proxy stub works with all versions of windows (the
# issues leading to the VBoxProxyStubLegacy.dll are only on 64-bit windows).
$(call KB_FN_AUTO_CMD_DEPS,$(VBoxCOM-x86_0_OUTDIR)/VirtualBox_i.c)
$(VBoxCOM-x86_0_OUTDIR)/VirtualBox_i.c \
$(if $(VBOX_WITH_MIDL_PROXY_STUB), + $(VBoxCOM-x86_0_OUTDIR)/VirtualBox_p.c + $(VBoxCOM-x86_0_OUTDIR)/dlldata.c,) \
+ $(VBoxCOM-x86_0_OUTDIR)/VirtualBox.h \
+ $(VBoxCOM-x86_0_OUTDIR)/VirtualBox-x86.tlb: $(VBOX_IDL_FILE.MSCOM) | $$(dir $$@)
	$(call KB_FN_AUTO_CMD_DEPS_COMMANDS)
	$(VBOX_WIN_MIDL) /nologo /W4 \
		/env win32 /target NT51 /robust /protocol all  \
		/out $(call VBOX_FN_MAKE_WIN_PATH,$(VBoxCOM-x86_0_OUTDIR)) \
		/tlb $(call VBOX_FN_MAKE_WIN_PATH,$(VBoxCOM-x86_0_OUTDIR)/VirtualBox-x86.tlb) \
		/cpp_cmd $(subst $(EXEC_X86_WIN32),,$(call VBOX_FN_MAKE_WIN_PATH,$(TOOL_$(VBOX_VCC_TOOL_STEM)X86_CC))) \
		/I $(call VBOX_FN_MAKE_WIN_PATH,$(PATH_SDK_$(VBOX_WINPSDK)_INC)) \
		/I idl \
		$(call VBOX_FN_MAKE_WIN_PATH,$(VBOX_IDL_FILE.MSCOM))
	$(call def_VBoxMainDisableMscWarnings,$(VBoxCOM-x86_0_OUTDIR)/VirtualBox.h)
	$(call def_VBoxMainDisableMscWarnings,$(VBoxCOM-x86_0_OUTDIR)/VirtualBox_i.c)
	$(call def_VBoxMainDisableMscWarnings,$(VBoxCOM-x86_0_OUTDIR)/VirtualBox_p.c)

#
# Translation stuff
#
VBoxSVC_VBOX_HEADERS = \
	include/collection.h \
	include/MachineImpl.h
VBoxSVC_VBOX_TRANSLATIONS = \
	nls/VBoxSVC_de.ts

VBoxC_VBOX_HEADERS = \
	include/ConsoleImpl.h

VBoxC_VBOX_INTERMEDIATES   = $(VBOX_MAIN_APIWRAPPER_GEN_HDRS)
VBoxC_VBOX_HEADERS += $(VBOX_MAIN_APIWRAPPER_INCS)

VBoxC_VBOX_TRANSLATIONS = \
	nls/VBoxC_de.ts

ifdef VBOX_WITH_JMSCOM

 #
 # Java glue JAR files
 #
 VBOX_JMSCOM_JAR     = $(VBoxJMscom-inst-jar_0_OUTDIR)/vboxjmscom.jar
 VBOX_JMSCOM_TARGET := $(PATH_TARGET)/vboxjmscom-gen
 VBOX_JMSCOM_GEN     = $(VBOX_JMSCOM_TARGET)/jmscomgen
 VBOX_JMSCOM_JDEST  := $(VBOX_JMSCOM_TARGET)/jdest
 VBOX_GLUE_XSLT_DIR := $(PATH_ROOT)/src/VBox/Main/glue
 VBOX_JACOB_DIR     := $(PATH_ROOT)/src/libs/jacob-1.17

 INSTALLS += VBoxJMscom-inst-jar
 VBoxJMscom-inst-jar_INST = $(INST_SDK)bindings/mscom/java/
 VBoxJMscom-inst-jar_MODE = a+r,u+w
 VBoxJMscom-inst-jar_SOURCES = \
 	$(VBoxJMscom-inst-jar_0_OUTDIR)/vboxjmscom.jar
 VBoxJMscom-inst-jar_CLEAN = \
 	$(VBoxJMscom-inst-jar_0_OUTDIR)/vboxjmscom.jar \
 	$(VBOX_JMSCOM_GEN)/jmscomglue.list \
 	$(wildcard \
 		$(VBOX_JMSCOM_GEN)/java/*.java \
 		$(VBOX_JMSCOM_JDEST)/*.class \
 		$(VBOX_JMSCOM_JDEST)/*/*.class \
 		$(VBOX_JMSCOM_JDEST)/*/*/*.class \
 		$(VBOX_JMSCOM_JDEST)/*/*/*/*.class \
 	)
 VBoxJMscom-inst-jar_BLDDIRS += $(VBOX_JMSCOM_GEN)/java
 $(call KB_FN_DO_PASS0_ON_TARGET,VBoxJMscom-inst-jar) # Sets VBoxJMscom-inst-jar_0_OUTDIR

 $(call KB_FN_AUTO_CMD_DEPS,$(VBOX_JMSCOM_GEN)/jmscomglue.list)
 $(VBOX_JMSCOM_GEN)/jmscomglue.list: \
		$(VBOX_XIDL_FILE) \
		$(VBOX_GLUE_XSLT_DIR)/glue-java.xsl \
		$(VBOX_FILESPLIT) \
		| $(VBOX_JMSCOM_GEN)/java/
	$(call KB_FN_AUTO_CMD_DEPS_COMMANDS)
	$(call MSG_L1,Generating Java MSCOM glue files from XIDL)
	$(QUIET)$(RM) -f $(wildcard $(VBOX_JMSCOM_GEN)/java/*.java)
	$(QUIET)$(VBOX_XSLTPROC) \
		--stringparam filelistonly "" \
		--stringparam G_vboxApiSuffix $(VBOX_API_SUFFIX) \
		--stringparam G_vboxGlueStyle mscom \
		--stringparam G_vboxDirPrefix "" \
		-o $(VBOX_JMSCOM_GEN)/java/merged.file $(VBOX_GLUE_XSLT_DIR)/glue-java.xsl $(VBOX_XIDL_FILE)
	$(QUIET)$(VBOX_FILESPLIT) $(VBOX_JMSCOM_GEN)/java/merged.file $(VBOX_JMSCOM_GEN)/java
	$(QUIET)echo $(VBOX_JMSCOM_GEN)/java/*.java > $@

 $(call KB_FN_AUTO_CMD_DEPS,$(VBoxJMscom-inst-jar_0_OUTDIR)/vboxjmscom.jar)
 $(VBoxJMscom-inst-jar_0_OUTDIR)/vboxjmscom.jar: $(VBOX_JMSCOM_GEN)/jmscomglue.list | $$(dir $$@)
	$(call KB_FN_AUTO_CMD_DEPS_COMMANDS)
	$(call MSG_TOOL,javac,$(notdir $@),jmscomglue.list,)
	$(QUIET)$(RM) -Rf $(VBOX_JMSCOM_JDEST)
	$(QUIET)$(MKDIR) -p $(VBOX_JMSCOM_JDEST)
	$(call MSG_TOOL,javac,$(notdir $@),...,)
	$(QUIET)$(VBOX_JAVAC) $(VBOX_JAVAC_OPTS) @$(VBOX_JMSCOM_GEN)/jmscomglue.list \
		-d $(VBOX_JMSCOM_JDEST) -classpath "$(VBOX_JMSCOM_JDEST)$(VBOX_SEP)$(VBOX_JACOB_DIR)/jacob.jar"
	$(call MSG_LINK,$(notdir $@),$@)
	$(QUIET)$(VBOX_JAR) cf $@ -C $(VBOX_JMSCOM_JDEST) .

 ## @todo compile TestVBox.java (see below) to have sanity checking
endif # VBOX_WITH_JMSCOM

#
# Install Java glue sample code.
#
INSTALLS += javagluesample
javagluesample_INST = $(INST_SDK)bindings/glue/java/
javagluesample_MODE = a+r,u+w
javagluesample_SOURCES = \
	$(VBOX_PATH_MAIN_SRC)/glue/tests/TestVBox.java=>TestVBox.java \
	$(VBOX_PATH_MAIN_SRC)/glue/tests/Makefile=>Makefile

#
# Rules associated with VBoxAPIWrap (in typical invocation order).
# We keep them down here to simplify the use of VBoxAPIWrap_0_OUTDIR.
#

# Generate a make include file which lists the wrapper header and source files.
$(call KB_FN_AUTO_CMD_DEPS,$(VBoxAPIWrap_VBOX_KMK_FILE).ts)
$(VBoxAPIWrap_VBOX_KMK_FILE).ts \
+| $(VBoxAPIWrap_VBOX_KMK_FILE): \
		$(VBOX_XIDL_FILE) \
		$(VBOX_PATH_MAIN_SRC)/idl/apiwrap-server-filelist.xsl \
		$(VBOX_PATH_MAIN_SRC)/Makefile.kmk
	$(call KB_FN_AUTO_CMD_DEPS_COMMANDS)
	$(call MSG_GENERATE,,$(VBoxAPIWrap_VBOX_KMK_FILE))
	$(QUIET)$(RM) -f $@
	$(QUIET)$(MKDIR) -p $(@D)
	$(QUIET)$(VBOX_XSLTPROC) --stringparam KBUILD_HOST $(KBUILD_HOST) \
		$(if $(VBOX_WITH_SDS),-stringparam g_fVBoxWithSDS yes,) \
		-o $@ $(VBOX_PATH_MAIN_SRC)/idl/apiwrap-server-filelist.xsl $(VBOX_XIDL_FILE)
	$(QUIET)$(CP) --changed -fv $@ $(VBoxAPIWrap_VBOX_KMK_FILE)

# Generate the header files for the wrappers.
$(call KB_FN_AUTO_CMD_DEPS,$(VBoxAPIWrap_0_OUTDIR)/apiwrappers-headers)
$(VBoxAPIWrap_0_OUTDIR)/apiwrappers-headers \
+| $(VBOX_MAIN_APIWRAPPER_GEN_HDRS): \
		$(VBOX_XIDL_FILE) \
               $(VBOX_PATH_MAIN_SRC)/idl/typemap-shared.inc.xsl \
		$(VBoxAPIWrap_VBOX_XSLT) \
		$(VBOX_FILESPLIT) \
		| $$(dir $$@)
	$(call KB_FN_AUTO_CMD_DEPS_COMMANDS)
	$(call MSG_L1,Generating C++ Server API wrapper header files from XIDL)
	$(QUIET)$(RM) -f -- $(filter-out $(VBOX_MAIN_APIWRAPPER_GEN_HDRS), $(wildcard $(VBoxAPIWrap_0_OUTDIR)/*.h))
	$(QUIET)$(VBOX_XSLTPROC) --stringparam KBUILD_HOST $(KBUILD_HOST) \
		--stringparam generating "headers" \
		-o $@ $(VBoxAPIWrap_VBOX_XSLT) $(VBOX_XIDL_FILE)
	$(QUIET)$(VBOX_FILESPLIT) $@ $(VBoxAPIWrap_0_OUTDIR)

# Generate the DTrace probes for the wrappers and combine them with handcoded probes.
$(call KB_FN_AUTO_CMD_DEPS,$(VBoxAPIWrap_0_OUTDIR)/VBoxAPI.d.ts)
$(VBoxAPIWrap_0_OUTDIR)/VBoxAPI.d.ts \
+| $(VBoxAPIWrap_0_OUTDIR)/VBoxAPI.d: \
		$(VBOX_XIDL_FILE) \
               $(VBOX_PATH_MAIN_SRC)/idl/typemap-shared.inc.xsl \
		$(VBoxAPIWrap_VBOX_XSLT) \
		$(VBOX_FILESPLIT) \
		| $$(dir $$@)
	$(call KB_FN_AUTO_CMD_DEPS_COMMANDS)
	$(call MSG_L1,Generating DTrace Provider for the VBox API (from XIDL))
	$(QUIET)$(RM) -f -- "$@" "$@.tmp"
	$(QUIET)$(VBOX_XSLTPROC) --stringparam KBUILD_HOST $(KBUILD_HOST) \
		--stringparam generating "dtrace-probes" \
		-o "$@" $(VBoxAPIWrap_VBOX_XSLT) $(VBOX_XIDL_FILE)
	$(QUIET)$(SED) -e '' -o "$@.tmp" \
		"$(VBOX_PATH_MAIN_SRC)/src-all/VBoxAPI-start$(if-expr "$(VBOX_HOST_DTRACE_VERSION)" == "dtrace: Sun D 1.6.2",-alternative,).d" \
		"$@" \
		"$(VBOX_PATH_MAIN_SRC)/src-all/VBoxAPI-end$(if-expr "$(VBOX_HOST_DTRACE_VERSION)" == "dtrace: Sun D 1.6.2",-alternative,).d"
	$(QUIET)$(MV) -- "$@.tmp" "$@"
	$(QUIET)$(CP) --changed -fv -- "$@" "$(VBoxAPIWrap_0_OUTDIR)/VBoxAPI.d"

# Generate the wrapper source files - split in two due to long processing time
$(call KB_FN_AUTO_CMD_DEPS,$(VBoxAPIWrap_0_OUTDIR)/apiwrappers-sources-even)
$(VBoxAPIWrap_0_OUTDIR)/apiwrappers-sources-even \
+| $(VBOX_MAIN_APIWRAPPER_GEN_SRCS_EVEN): \
		$(VBOX_XIDL_FILE) \
               $(VBOX_PATH_MAIN_SRC)/idl/typemap-shared.inc.xsl \
		$(VBoxAPIWrap_VBOX_XSLT) \
		$(VBOX_FILESPLIT) \
		| $$(dir $$@)
	$(call KB_FN_AUTO_CMD_DEPS_COMMANDS)
	$(call MSG_L1,Generating C++ Server API wrapper files from XIDL - part 1)
	$(QUIET)$(RM) -f -- $(filter-out $(VBOX_MAIN_APIWRAPPER_GEN_SRCS), $(wildcard $(VBoxAPIWrap_0_OUTDIR)/*.cpp))
	$(QUIET)$(VBOX_XSLTPROC) --stringparam KBUILD_HOST $(KBUILD_HOST) \
		--stringparam generating "sources" \
		--param reminder 0 \
		-o $@ $(VBoxAPIWrap_VBOX_XSLT) $(VBOX_XIDL_FILE)
	$(QUIET)$(VBOX_FILESPLIT) $@ $(VBoxAPIWrap_0_OUTDIR)

$(call KB_FN_AUTO_CMD_DEPS,$(VBoxAPIWrap_0_OUTDIR)/apiwrappers-sources-odd)
$(VBoxAPIWrap_0_OUTDIR)/apiwrappers-sources-odd \
+| $(VBOX_MAIN_APIWRAPPER_GEN_SRCS_ODD): \
		$(VBOX_XIDL_FILE) \
               $(VBOX_PATH_MAIN_SRC)/idl/typemap-shared.inc.xsl \
		$(VBoxAPIWrap_VBOX_XSLT) \
		$(VBOX_FILESPLIT) \
		| $$(dir $$@)
	$(call KB_FN_AUTO_CMD_DEPS_COMMANDS)
	$(call MSG_L1,Generating C++ Server API wrapper files from XIDL - part 2)
	$(QUIET)$(RM) -f -- $(filter-out $(VBOX_MAIN_APIWRAPPER_GEN_SRCS), $(wildcard $(VBoxAPIWrap_0_OUTDIR)/*.cpp))
	$(QUIET)$(VBOX_XSLTPROC) --stringparam KBUILD_HOST $(KBUILD_HOST) \
		--stringparam generating "sources" \
		--param reminder 1 \
		-o $@ $(VBoxAPIWrap_VBOX_XSLT) $(VBOX_XIDL_FILE)
	$(QUIET)$(VBOX_FILESPLIT) $@ $(VBoxAPIWrap_0_OUTDIR)

testapiwrappers:: \
	$(VBoxAPIWrap_0_OUTDIR)/apiwrappers-headers \
	$(VBoxAPIWrap_0_OUTDIR)/VBoxAPI.d.ts \
	$(VBoxAPIWrap_0_OUTDIR)/apiwrappers-sources-odd \
	$(VBoxAPIWrap_0_OUTDIR)/apiwrappers-sources-even


#
# NLS stuff.
#
updatenls::
	$(VBOX_LUPDATE) $(VBoxSVC_SOURCES) $(VBoxSVC_VBOX_HEADERS) -ts $(VBoxSVC_VBOX_TRANSLATIONS)
	$(VBOX_LUPDATE) $(VBoxC_SOURCES) $(VBoxC_VBOX_HEADERS) -ts $(VBoxC_VBOX_TRANSLATIONS)

